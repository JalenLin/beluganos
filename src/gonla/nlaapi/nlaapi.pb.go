// Code generated by protoc-gen-go. DO NOT EDIT.
// source: nlaapi.proto

/*
Package nlaapi is a generated protocol buffer package.

It is generated from these files:
	nlaapi.proto

It has these top-level messages:
	NlMsghdr
	NetlinkMessage
	NetlinkMessageReply
	MonNetlinkRequest
	NlMsgUni
	NetlinkMessageUnion
	ModVpnRequest
	ModVpnReply
	ModNetlinkReply
	GetLinksRequest
	GetAddrsRequest
	GetNeighsRequest
	GetRoutesRequest
	GetMplssRequest
	GetNodesRequest
	GetVpnsRequest
	GetEncapInfosRequest
	GetStatsRequest
	LinkKey
	AddrKey
	NeighKey
	RouteKey
	MplsKey
	NodeKey
	VpnKey
	Stat
	Node
	Vpn
	LinkAttrs
	GenericLinkAttrs
	DeviceLinkAttrs
	BridgeLinkAttrs
	VlanLinkAttrs
	VxlanLinkAttrs
	VtiLinkAttrs
	VethLinkAttrs
	BondAdInfo
	BondLinkAttrs
	Link
	Addr
	Neigh
	NexthopInfo
	MPLSDestination
	Destination
	MPLSEncap
	Encap
	EncapInfoKey
	EncapInfo
	Route
*/
package nlaapi

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

//
// Message Source
//
type NlMsgSrc int32

const (
	NlMsgSrc_NOP NlMsgSrc = 0
	NlMsgSrc_KNL NlMsgSrc = 1
	NlMsgSrc_API NlMsgSrc = 2
)

var NlMsgSrc_name = map[int32]string{
	0: "NOP",
	1: "KNL",
	2: "API",
}
var NlMsgSrc_value = map[string]int32{
	"NOP": 0,
	"KNL": 1,
	"API": 2,
}

func (x NlMsgSrc) String() string {
	return proto.EnumName(NlMsgSrc_name, int32(x))
}
func (NlMsgSrc) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type LinkOperState int32

const (
	LinkOperState_OperUnknown        LinkOperState = 0
	LinkOperState_OperNotPresent     LinkOperState = 1
	LinkOperState_OperDown           LinkOperState = 2
	LinkOperState_OperLowerLayerDown LinkOperState = 3
	LinkOperState_OperTesting        LinkOperState = 4
	LinkOperState_OperDormant        LinkOperState = 5
	LinkOperState_OperUp             LinkOperState = 6
)

var LinkOperState_name = map[int32]string{
	0: "OperUnknown",
	1: "OperNotPresent",
	2: "OperDown",
	3: "OperLowerLayerDown",
	4: "OperTesting",
	5: "OperDormant",
	6: "OperUp",
}
var LinkOperState_value = map[string]int32{
	"OperUnknown":        0,
	"OperNotPresent":     1,
	"OperDown":           2,
	"OperLowerLayerDown": 3,
	"OperTesting":        4,
	"OperDormant":        5,
	"OperUp":             6,
}

func (x LinkOperState) String() string {
	return proto.EnumName(LinkOperState_name, int32(x))
}
func (LinkOperState) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type BondMode int32

const (
	BondMode_BOND_MODE_BALANCE_RR    BondMode = 0
	BondMode_BOND_MODE_ACTIVE_BACKUP BondMode = 1
	BondMode_BOND_MODE_BALANCE_XOR   BondMode = 2
	BondMode_BOND_MODE_BROADCAST     BondMode = 3
	BondMode_BOND_MODE_802_3AD       BondMode = 4
	BondMode_BOND_MODE_BALANCE_TLB   BondMode = 5
	BondMode_BOND_MODE_BALANCE_ALB   BondMode = 6
	BondMode_BOND_MODE_UNKNOWN       BondMode = 7
)

var BondMode_name = map[int32]string{
	0: "BOND_MODE_BALANCE_RR",
	1: "BOND_MODE_ACTIVE_BACKUP",
	2: "BOND_MODE_BALANCE_XOR",
	3: "BOND_MODE_BROADCAST",
	4: "BOND_MODE_802_3AD",
	5: "BOND_MODE_BALANCE_TLB",
	6: "BOND_MODE_BALANCE_ALB",
	7: "BOND_MODE_UNKNOWN",
}
var BondMode_value = map[string]int32{
	"BOND_MODE_BALANCE_RR":    0,
	"BOND_MODE_ACTIVE_BACKUP": 1,
	"BOND_MODE_BALANCE_XOR":   2,
	"BOND_MODE_BROADCAST":     3,
	"BOND_MODE_802_3AD":       4,
	"BOND_MODE_BALANCE_TLB":   5,
	"BOND_MODE_BALANCE_ALB":   6,
	"BOND_MODE_UNKNOWN":       7,
}

func (x BondMode) String() string {
	return proto.EnumName(BondMode_name, int32(x))
}
func (BondMode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type BondArpValidate int32

const (
	BondArpValidate_BOND_ARP_VALIDATE_NONE   BondArpValidate = 0
	BondArpValidate_BOND_ARP_VALIDATE_ACTIVE BondArpValidate = 1
	BondArpValidate_BOND_ARP_VALIDATE_BACKUP BondArpValidate = 2
	BondArpValidate_BOND_ARP_VALIDATE_ALL    BondArpValidate = 3
)

var BondArpValidate_name = map[int32]string{
	0: "BOND_ARP_VALIDATE_NONE",
	1: "BOND_ARP_VALIDATE_ACTIVE",
	2: "BOND_ARP_VALIDATE_BACKUP",
	3: "BOND_ARP_VALIDATE_ALL",
}
var BondArpValidate_value = map[string]int32{
	"BOND_ARP_VALIDATE_NONE":   0,
	"BOND_ARP_VALIDATE_ACTIVE": 1,
	"BOND_ARP_VALIDATE_BACKUP": 2,
	"BOND_ARP_VALIDATE_ALL":    3,
}

func (x BondArpValidate) String() string {
	return proto.EnumName(BondArpValidate_name, int32(x))
}
func (BondArpValidate) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type BondArpAllTargets int32

const (
	BondArpAllTargets_BOND_ARP_ALL_TARGETS_ANY BondArpAllTargets = 0
	BondArpAllTargets_BOND_ARP_ALL_TARGETS_ALL BondArpAllTargets = 1
)

var BondArpAllTargets_name = map[int32]string{
	0: "BOND_ARP_ALL_TARGETS_ANY",
	1: "BOND_ARP_ALL_TARGETS_ALL",
}
var BondArpAllTargets_value = map[string]int32{
	"BOND_ARP_ALL_TARGETS_ANY": 0,
	"BOND_ARP_ALL_TARGETS_ALL": 1,
}

func (x BondArpAllTargets) String() string {
	return proto.EnumName(BondArpAllTargets_name, int32(x))
}
func (BondArpAllTargets) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type BondPrimaryReselect int32

const (
	BondPrimaryReselect_BOND_PRIMARY_RESELECT_ALWAYS  BondPrimaryReselect = 0
	BondPrimaryReselect_BOND_PRIMARY_RESELECT_BETTER  BondPrimaryReselect = 1
	BondPrimaryReselect_BOND_PRIMARY_RESELECT_FAILURE BondPrimaryReselect = 2
)

var BondPrimaryReselect_name = map[int32]string{
	0: "BOND_PRIMARY_RESELECT_ALWAYS",
	1: "BOND_PRIMARY_RESELECT_BETTER",
	2: "BOND_PRIMARY_RESELECT_FAILURE",
}
var BondPrimaryReselect_value = map[string]int32{
	"BOND_PRIMARY_RESELECT_ALWAYS":  0,
	"BOND_PRIMARY_RESELECT_BETTER":  1,
	"BOND_PRIMARY_RESELECT_FAILURE": 2,
}

func (x BondPrimaryReselect) String() string {
	return proto.EnumName(BondPrimaryReselect_name, int32(x))
}
func (BondPrimaryReselect) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type BondFailOverMac int32

const (
	BondFailOverMac_BOND_FAIL_OVER_MAC_NONE   BondFailOverMac = 0
	BondFailOverMac_BOND_FAIL_OVER_MAC_ACTIVE BondFailOverMac = 1
	BondFailOverMac_BOND_FAIL_OVER_MAC_FOLLOW BondFailOverMac = 2
)

var BondFailOverMac_name = map[int32]string{
	0: "BOND_FAIL_OVER_MAC_NONE",
	1: "BOND_FAIL_OVER_MAC_ACTIVE",
	2: "BOND_FAIL_OVER_MAC_FOLLOW",
}
var BondFailOverMac_value = map[string]int32{
	"BOND_FAIL_OVER_MAC_NONE":   0,
	"BOND_FAIL_OVER_MAC_ACTIVE": 1,
	"BOND_FAIL_OVER_MAC_FOLLOW": 2,
}

func (x BondFailOverMac) String() string {
	return proto.EnumName(BondFailOverMac_name, int32(x))
}
func (BondFailOverMac) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type BondXmitHashPolicy int32

const (
	BondXmitHashPolicy_BOND_XMIT_HASH_POLICY_LAYER2   BondXmitHashPolicy = 0
	BondXmitHashPolicy_BOND_XMIT_HASH_POLICY_LAYER3_4 BondXmitHashPolicy = 1
	BondXmitHashPolicy_BOND_XMIT_HASH_POLICY_LAYER2_3 BondXmitHashPolicy = 2
	BondXmitHashPolicy_BOND_XMIT_HASH_POLICY_ENCAP2_3 BondXmitHashPolicy = 3
	BondXmitHashPolicy_BOND_XMIT_HASH_POLICY_ENCAP3_4 BondXmitHashPolicy = 4
	BondXmitHashPolicy_BOND_XMIT_HASH_POLICY_UNKNOWN  BondXmitHashPolicy = 5
)

var BondXmitHashPolicy_name = map[int32]string{
	0: "BOND_XMIT_HASH_POLICY_LAYER2",
	1: "BOND_XMIT_HASH_POLICY_LAYER3_4",
	2: "BOND_XMIT_HASH_POLICY_LAYER2_3",
	3: "BOND_XMIT_HASH_POLICY_ENCAP2_3",
	4: "BOND_XMIT_HASH_POLICY_ENCAP3_4",
	5: "BOND_XMIT_HASH_POLICY_UNKNOWN",
}
var BondXmitHashPolicy_value = map[string]int32{
	"BOND_XMIT_HASH_POLICY_LAYER2":   0,
	"BOND_XMIT_HASH_POLICY_LAYER3_4": 1,
	"BOND_XMIT_HASH_POLICY_LAYER2_3": 2,
	"BOND_XMIT_HASH_POLICY_ENCAP2_3": 3,
	"BOND_XMIT_HASH_POLICY_ENCAP3_4": 4,
	"BOND_XMIT_HASH_POLICY_UNKNOWN":  5,
}

func (x BondXmitHashPolicy) String() string {
	return proto.EnumName(BondXmitHashPolicy_name, int32(x))
}
func (BondXmitHashPolicy) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type BondLacpRate int32

const (
	BondLacpRate_BOND_LACP_RATE_SLOW    BondLacpRate = 0
	BondLacpRate_BOND_LACP_RATE_FAST    BondLacpRate = 1
	BondLacpRate_BOND_LACP_RATE_UNKNOWN BondLacpRate = 2
)

var BondLacpRate_name = map[int32]string{
	0: "BOND_LACP_RATE_SLOW",
	1: "BOND_LACP_RATE_FAST",
	2: "BOND_LACP_RATE_UNKNOWN",
}
var BondLacpRate_value = map[string]int32{
	"BOND_LACP_RATE_SLOW":    0,
	"BOND_LACP_RATE_FAST":    1,
	"BOND_LACP_RATE_UNKNOWN": 2,
}

func (x BondLacpRate) String() string {
	return proto.EnumName(BondLacpRate_name, int32(x))
}
func (BondLacpRate) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type BondAdSelect int32

const (
	BondAdSelect_BOND_AD_SELECT_STABLE    BondAdSelect = 0
	BondAdSelect_BOND_AD_SELECT_BANDWIDTH BondAdSelect = 1
	BondAdSelect_BOND_AD_SELECT_COUNT     BondAdSelect = 2
)

var BondAdSelect_name = map[int32]string{
	0: "BOND_AD_SELECT_STABLE",
	1: "BOND_AD_SELECT_BANDWIDTH",
	2: "BOND_AD_SELECT_COUNT",
}
var BondAdSelect_value = map[string]int32{
	"BOND_AD_SELECT_STABLE":    0,
	"BOND_AD_SELECT_BANDWIDTH": 1,
	"BOND_AD_SELECT_COUNT":     2,
}

func (x BondAdSelect) String() string {
	return proto.EnumName(BondAdSelect_name, int32(x))
}
func (BondAdSelect) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

//
// Common
//
type NlMsghdr struct {
	Len   uint32 `protobuf:"varint,1,opt,name=len" json:"len,omitempty"`
	Type  uint32 `protobuf:"varint,2,opt,name=type" json:"type,omitempty"`
	Flags uint32 `protobuf:"varint,3,opt,name=flags" json:"flags,omitempty"`
	Seq   uint32 `protobuf:"varint,4,opt,name=seq" json:"seq,omitempty"`
	Pid   uint32 `protobuf:"varint,5,opt,name=pid" json:"pid,omitempty"`
}

func (m *NlMsghdr) Reset()                    { *m = NlMsghdr{} }
func (m *NlMsghdr) String() string            { return proto.CompactTextString(m) }
func (*NlMsghdr) ProtoMessage()               {}
func (*NlMsghdr) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *NlMsghdr) GetLen() uint32 {
	if m != nil {
		return m.Len
	}
	return 0
}

func (m *NlMsghdr) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *NlMsghdr) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *NlMsghdr) GetSeq() uint32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *NlMsghdr) GetPid() uint32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

type NetlinkMessage struct {
	Header *NlMsghdr `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Data   []byte    `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	NId    uint32    `protobuf:"varint,3,opt,name=n_id,json=nId" json:"n_id,omitempty"`
	Src    NlMsgSrc  `protobuf:"varint,4,opt,name=src,enum=nlaapi.NlMsgSrc" json:"src,omitempty"`
}

func (m *NetlinkMessage) Reset()                    { *m = NetlinkMessage{} }
func (m *NetlinkMessage) String() string            { return proto.CompactTextString(m) }
func (*NetlinkMessage) ProtoMessage()               {}
func (*NetlinkMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *NetlinkMessage) GetHeader() *NlMsghdr {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *NetlinkMessage) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *NetlinkMessage) GetNId() uint32 {
	if m != nil {
		return m.NId
	}
	return 0
}

func (m *NetlinkMessage) GetSrc() NlMsgSrc {
	if m != nil {
		return m.Src
	}
	return NlMsgSrc_NOP
}

type NetlinkMessageReply struct {
}

func (m *NetlinkMessageReply) Reset()                    { *m = NetlinkMessageReply{} }
func (m *NetlinkMessageReply) String() string            { return proto.CompactTextString(m) }
func (*NetlinkMessageReply) ProtoMessage()               {}
func (*NetlinkMessageReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type MonNetlinkRequest struct {
}

func (m *MonNetlinkRequest) Reset()                    { *m = MonNetlinkRequest{} }
func (m *MonNetlinkRequest) String() string            { return proto.CompactTextString(m) }
func (*MonNetlinkRequest) ProtoMessage()               {}
func (*MonNetlinkRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type NlMsgUni struct {
	// Types that are valid to be assigned to Msg:
	//	*NlMsgUni_Link
	//	*NlMsgUni_Addr
	//	*NlMsgUni_Neigh
	//	*NlMsgUni_Route
	//	*NlMsgUni_Node
	//	*NlMsgUni_Vpn
	Msg isNlMsgUni_Msg `protobuf_oneof:"msg"`
}

func (m *NlMsgUni) Reset()                    { *m = NlMsgUni{} }
func (m *NlMsgUni) String() string            { return proto.CompactTextString(m) }
func (*NlMsgUni) ProtoMessage()               {}
func (*NlMsgUni) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type isNlMsgUni_Msg interface {
	isNlMsgUni_Msg()
}

type NlMsgUni_Link struct {
	Link *Link `protobuf:"bytes,1,opt,name=link,oneof"`
}
type NlMsgUni_Addr struct {
	Addr *Addr `protobuf:"bytes,2,opt,name=addr,oneof"`
}
type NlMsgUni_Neigh struct {
	Neigh *Neigh `protobuf:"bytes,3,opt,name=neigh,oneof"`
}
type NlMsgUni_Route struct {
	Route *Route `protobuf:"bytes,4,opt,name=route,oneof"`
}
type NlMsgUni_Node struct {
	Node *Node `protobuf:"bytes,5,opt,name=node,oneof"`
}
type NlMsgUni_Vpn struct {
	Vpn *Vpn `protobuf:"bytes,6,opt,name=vpn,oneof"`
}

func (*NlMsgUni_Link) isNlMsgUni_Msg()  {}
func (*NlMsgUni_Addr) isNlMsgUni_Msg()  {}
func (*NlMsgUni_Neigh) isNlMsgUni_Msg() {}
func (*NlMsgUni_Route) isNlMsgUni_Msg() {}
func (*NlMsgUni_Node) isNlMsgUni_Msg()  {}
func (*NlMsgUni_Vpn) isNlMsgUni_Msg()   {}

func (m *NlMsgUni) GetMsg() isNlMsgUni_Msg {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *NlMsgUni) GetLink() *Link {
	if x, ok := m.GetMsg().(*NlMsgUni_Link); ok {
		return x.Link
	}
	return nil
}

func (m *NlMsgUni) GetAddr() *Addr {
	if x, ok := m.GetMsg().(*NlMsgUni_Addr); ok {
		return x.Addr
	}
	return nil
}

func (m *NlMsgUni) GetNeigh() *Neigh {
	if x, ok := m.GetMsg().(*NlMsgUni_Neigh); ok {
		return x.Neigh
	}
	return nil
}

func (m *NlMsgUni) GetRoute() *Route {
	if x, ok := m.GetMsg().(*NlMsgUni_Route); ok {
		return x.Route
	}
	return nil
}

func (m *NlMsgUni) GetNode() *Node {
	if x, ok := m.GetMsg().(*NlMsgUni_Node); ok {
		return x.Node
	}
	return nil
}

func (m *NlMsgUni) GetVpn() *Vpn {
	if x, ok := m.GetMsg().(*NlMsgUni_Vpn); ok {
		return x.Vpn
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*NlMsgUni) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _NlMsgUni_OneofMarshaler, _NlMsgUni_OneofUnmarshaler, _NlMsgUni_OneofSizer, []interface{}{
		(*NlMsgUni_Link)(nil),
		(*NlMsgUni_Addr)(nil),
		(*NlMsgUni_Neigh)(nil),
		(*NlMsgUni_Route)(nil),
		(*NlMsgUni_Node)(nil),
		(*NlMsgUni_Vpn)(nil),
	}
}

func _NlMsgUni_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*NlMsgUni)
	// msg
	switch x := m.Msg.(type) {
	case *NlMsgUni_Link:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Link); err != nil {
			return err
		}
	case *NlMsgUni_Addr:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Addr); err != nil {
			return err
		}
	case *NlMsgUni_Neigh:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Neigh); err != nil {
			return err
		}
	case *NlMsgUni_Route:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Route); err != nil {
			return err
		}
	case *NlMsgUni_Node:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Node); err != nil {
			return err
		}
	case *NlMsgUni_Vpn:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Vpn); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("NlMsgUni.Msg has unexpected type %T", x)
	}
	return nil
}

func _NlMsgUni_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*NlMsgUni)
	switch tag {
	case 1: // msg.link
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Link)
		err := b.DecodeMessage(msg)
		m.Msg = &NlMsgUni_Link{msg}
		return true, err
	case 2: // msg.addr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Addr)
		err := b.DecodeMessage(msg)
		m.Msg = &NlMsgUni_Addr{msg}
		return true, err
	case 3: // msg.neigh
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Neigh)
		err := b.DecodeMessage(msg)
		m.Msg = &NlMsgUni_Neigh{msg}
		return true, err
	case 4: // msg.route
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Route)
		err := b.DecodeMessage(msg)
		m.Msg = &NlMsgUni_Route{msg}
		return true, err
	case 5: // msg.node
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Node)
		err := b.DecodeMessage(msg)
		m.Msg = &NlMsgUni_Node{msg}
		return true, err
	case 6: // msg.vpn
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Vpn)
		err := b.DecodeMessage(msg)
		m.Msg = &NlMsgUni_Vpn{msg}
		return true, err
	default:
		return false, nil
	}
}

func _NlMsgUni_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*NlMsgUni)
	// msg
	switch x := m.Msg.(type) {
	case *NlMsgUni_Link:
		s := proto.Size(x.Link)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NlMsgUni_Addr:
		s := proto.Size(x.Addr)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NlMsgUni_Neigh:
		s := proto.Size(x.Neigh)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NlMsgUni_Route:
		s := proto.Size(x.Route)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NlMsgUni_Node:
		s := proto.Size(x.Node)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NlMsgUni_Vpn:
		s := proto.Size(x.Vpn)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type NetlinkMessageUnion struct {
	Header *NlMsghdr `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Msg    *NlMsgUni `protobuf:"bytes,2,opt,name=msg" json:"msg,omitempty"`
	NId    uint32    `protobuf:"varint,3,opt,name=n_id,json=nId" json:"n_id,omitempty"`
	Src    NlMsgSrc  `protobuf:"varint,4,opt,name=src,enum=nlaapi.NlMsgSrc" json:"src,omitempty"`
}

func (m *NetlinkMessageUnion) Reset()                    { *m = NetlinkMessageUnion{} }
func (m *NetlinkMessageUnion) String() string            { return proto.CompactTextString(m) }
func (*NetlinkMessageUnion) ProtoMessage()               {}
func (*NetlinkMessageUnion) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *NetlinkMessageUnion) GetHeader() *NlMsghdr {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *NetlinkMessageUnion) GetMsg() *NlMsgUni {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *NetlinkMessageUnion) GetNId() uint32 {
	if m != nil {
		return m.NId
	}
	return 0
}

func (m *NetlinkMessageUnion) GetSrc() NlMsgSrc {
	if m != nil {
		return m.Src
	}
	return NlMsgSrc_NOP
}

type ModVpnRequest struct {
	Type uint32 `protobuf:"varint,1,opt,name=type" json:"type,omitempty"`
	Vpn  *Vpn   `protobuf:"bytes,2,opt,name=vpn" json:"vpn,omitempty"`
}

func (m *ModVpnRequest) Reset()                    { *m = ModVpnRequest{} }
func (m *ModVpnRequest) String() string            { return proto.CompactTextString(m) }
func (*ModVpnRequest) ProtoMessage()               {}
func (*ModVpnRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ModVpnRequest) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ModVpnRequest) GetVpn() *Vpn {
	if m != nil {
		return m.Vpn
	}
	return nil
}

type ModVpnReply struct {
}

func (m *ModVpnReply) Reset()                    { *m = ModVpnReply{} }
func (m *ModVpnReply) String() string            { return proto.CompactTextString(m) }
func (*ModVpnReply) ProtoMessage()               {}
func (*ModVpnReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type ModNetlinkReply struct {
}

func (m *ModNetlinkReply) Reset()                    { *m = ModNetlinkReply{} }
func (m *ModNetlinkReply) String() string            { return proto.CompactTextString(m) }
func (*ModNetlinkReply) ProtoMessage()               {}
func (*ModNetlinkReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type GetLinksRequest struct {
}

func (m *GetLinksRequest) Reset()                    { *m = GetLinksRequest{} }
func (m *GetLinksRequest) String() string            { return proto.CompactTextString(m) }
func (*GetLinksRequest) ProtoMessage()               {}
func (*GetLinksRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type GetAddrsRequest struct {
}

func (m *GetAddrsRequest) Reset()                    { *m = GetAddrsRequest{} }
func (m *GetAddrsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetAddrsRequest) ProtoMessage()               {}
func (*GetAddrsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

type GetNeighsRequest struct {
}

func (m *GetNeighsRequest) Reset()                    { *m = GetNeighsRequest{} }
func (m *GetNeighsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetNeighsRequest) ProtoMessage()               {}
func (*GetNeighsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type GetRoutesRequest struct {
}

func (m *GetRoutesRequest) Reset()                    { *m = GetRoutesRequest{} }
func (m *GetRoutesRequest) String() string            { return proto.CompactTextString(m) }
func (*GetRoutesRequest) ProtoMessage()               {}
func (*GetRoutesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

type GetMplssRequest struct {
}

func (m *GetMplssRequest) Reset()                    { *m = GetMplssRequest{} }
func (m *GetMplssRequest) String() string            { return proto.CompactTextString(m) }
func (*GetMplssRequest) ProtoMessage()               {}
func (*GetMplssRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

type GetNodesRequest struct {
}

func (m *GetNodesRequest) Reset()                    { *m = GetNodesRequest{} }
func (m *GetNodesRequest) String() string            { return proto.CompactTextString(m) }
func (*GetNodesRequest) ProtoMessage()               {}
func (*GetNodesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

type GetVpnsRequest struct {
}

func (m *GetVpnsRequest) Reset()                    { *m = GetVpnsRequest{} }
func (m *GetVpnsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetVpnsRequest) ProtoMessage()               {}
func (*GetVpnsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

type GetEncapInfosRequest struct {
}

func (m *GetEncapInfosRequest) Reset()                    { *m = GetEncapInfosRequest{} }
func (m *GetEncapInfosRequest) String() string            { return proto.CompactTextString(m) }
func (*GetEncapInfosRequest) ProtoMessage()               {}
func (*GetEncapInfosRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

type GetStatsRequest struct {
}

func (m *GetStatsRequest) Reset()                    { *m = GetStatsRequest{} }
func (m *GetStatsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetStatsRequest) ProtoMessage()               {}
func (*GetStatsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

type LinkKey struct {
	NId   uint32 `protobuf:"varint,1,opt,name=n_id,json=nId" json:"n_id,omitempty"`
	Index int32  `protobuf:"varint,2,opt,name=index" json:"index,omitempty"`
}

func (m *LinkKey) Reset()                    { *m = LinkKey{} }
func (m *LinkKey) String() string            { return proto.CompactTextString(m) }
func (*LinkKey) ProtoMessage()               {}
func (*LinkKey) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *LinkKey) GetNId() uint32 {
	if m != nil {
		return m.NId
	}
	return 0
}

func (m *LinkKey) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

type AddrKey struct {
	NId  uint32 `protobuf:"varint,1,opt,name=n_id,json=nId" json:"n_id,omitempty"`
	Addr string `protobuf:"bytes,2,opt,name=addr" json:"addr,omitempty"`
}

func (m *AddrKey) Reset()                    { *m = AddrKey{} }
func (m *AddrKey) String() string            { return proto.CompactTextString(m) }
func (*AddrKey) ProtoMessage()               {}
func (*AddrKey) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *AddrKey) GetNId() uint32 {
	if m != nil {
		return m.NId
	}
	return 0
}

func (m *AddrKey) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type NeighKey struct {
	NId  uint32 `protobuf:"varint,1,opt,name=n_id,json=nId" json:"n_id,omitempty"`
	Addr string `protobuf:"bytes,2,opt,name=addr" json:"addr,omitempty"`
}

func (m *NeighKey) Reset()                    { *m = NeighKey{} }
func (m *NeighKey) String() string            { return proto.CompactTextString(m) }
func (*NeighKey) ProtoMessage()               {}
func (*NeighKey) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *NeighKey) GetNId() uint32 {
	if m != nil {
		return m.NId
	}
	return 0
}

func (m *NeighKey) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type RouteKey struct {
	NId  uint32 `protobuf:"varint,1,opt,name=n_id,json=nId" json:"n_id,omitempty"`
	Addr string `protobuf:"bytes,2,opt,name=addr" json:"addr,omitempty"`
}

func (m *RouteKey) Reset()                    { *m = RouteKey{} }
func (m *RouteKey) String() string            { return proto.CompactTextString(m) }
func (*RouteKey) ProtoMessage()               {}
func (*RouteKey) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *RouteKey) GetNId() uint32 {
	if m != nil {
		return m.NId
	}
	return 0
}

func (m *RouteKey) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type MplsKey struct {
	NId    uint32 `protobuf:"varint,1,opt,name=n_id,json=nId" json:"n_id,omitempty"`
	LLabel uint32 `protobuf:"varint,2,opt,name=l_label,json=lLabel" json:"l_label,omitempty"`
}

func (m *MplsKey) Reset()                    { *m = MplsKey{} }
func (m *MplsKey) String() string            { return proto.CompactTextString(m) }
func (*MplsKey) ProtoMessage()               {}
func (*MplsKey) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *MplsKey) GetNId() uint32 {
	if m != nil {
		return m.NId
	}
	return 0
}

func (m *MplsKey) GetLLabel() uint32 {
	if m != nil {
		return m.LLabel
	}
	return 0
}

type NodeKey struct {
	NId uint32 `protobuf:"varint,1,opt,name=n_id,json=nId" json:"n_id,omitempty"`
}

func (m *NodeKey) Reset()                    { *m = NodeKey{} }
func (m *NodeKey) String() string            { return proto.CompactTextString(m) }
func (*NodeKey) ProtoMessage()               {}
func (*NodeKey) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *NodeKey) GetNId() uint32 {
	if m != nil {
		return m.NId
	}
	return 0
}

type VpnKey struct {
	NId uint32 `protobuf:"varint,1,opt,name=n_id,json=nId" json:"n_id,omitempty"`
	Dst string `protobuf:"bytes,2,opt,name=dst" json:"dst,omitempty"`
	Gw  string `protobuf:"bytes,3,opt,name=gw" json:"gw,omitempty"`
}

func (m *VpnKey) Reset()                    { *m = VpnKey{} }
func (m *VpnKey) String() string            { return proto.CompactTextString(m) }
func (*VpnKey) ProtoMessage()               {}
func (*VpnKey) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *VpnKey) GetNId() uint32 {
	if m != nil {
		return m.NId
	}
	return 0
}

func (m *VpnKey) GetDst() string {
	if m != nil {
		return m.Dst
	}
	return ""
}

func (m *VpnKey) GetGw() string {
	if m != nil {
		return m.Gw
	}
	return ""
}

//
// Messages
//
type Stat struct {
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Val uint64 `protobuf:"varint,2,opt,name=val" json:"val,omitempty"`
}

func (m *Stat) Reset()                    { *m = Stat{} }
func (m *Stat) String() string            { return proto.CompactTextString(m) }
func (*Stat) ProtoMessage()               {}
func (*Stat) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *Stat) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Stat) GetVal() uint64 {
	if m != nil {
		return m.Val
	}
	return 0
}

type Node struct {
	Ip  []byte `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip,omitempty"`
	NId uint32 `protobuf:"varint,2,opt,name=n_id,json=nId" json:"n_id,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *Node) GetIp() []byte {
	if m != nil {
		return m.Ip
	}
	return nil
}

func (m *Node) GetNId() uint32 {
	if m != nil {
		return m.NId
	}
	return 0
}

type Vpn struct {
	Ip    []byte `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip,omitempty"`
	Mask  []byte `protobuf:"bytes,2,opt,name=mask,proto3" json:"mask,omitempty"`
	Gw    []byte `protobuf:"bytes,3,opt,name=gw,proto3" json:"gw,omitempty"`
	Label uint32 `protobuf:"varint,4,opt,name=label" json:"label,omitempty"`
	VpnGw []byte `protobuf:"bytes,5,opt,name=vpn_gw,json=vpnGw,proto3" json:"vpn_gw,omitempty"`
	NId   uint32 `protobuf:"varint,6,opt,name=n_id,json=nId" json:"n_id,omitempty"`
	VpnId uint32 `protobuf:"varint,7,opt,name=vpn_id,json=vpnId" json:"vpn_id,omitempty"`
}

func (m *Vpn) Reset()                    { *m = Vpn{} }
func (m *Vpn) String() string            { return proto.CompactTextString(m) }
func (*Vpn) ProtoMessage()               {}
func (*Vpn) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *Vpn) GetIp() []byte {
	if m != nil {
		return m.Ip
	}
	return nil
}

func (m *Vpn) GetMask() []byte {
	if m != nil {
		return m.Mask
	}
	return nil
}

func (m *Vpn) GetGw() []byte {
	if m != nil {
		return m.Gw
	}
	return nil
}

func (m *Vpn) GetLabel() uint32 {
	if m != nil {
		return m.Label
	}
	return 0
}

func (m *Vpn) GetVpnGw() []byte {
	if m != nil {
		return m.VpnGw
	}
	return nil
}

func (m *Vpn) GetNId() uint32 {
	if m != nil {
		return m.NId
	}
	return 0
}

func (m *Vpn) GetVpnId() uint32 {
	if m != nil {
		return m.VpnId
	}
	return 0
}

type LinkAttrs struct {
	Index        int32         `protobuf:"varint,1,opt,name=index" json:"index,omitempty"`
	Mtu          int32         `protobuf:"varint,2,opt,name=mtu" json:"mtu,omitempty"`
	TxQLen       int32         `protobuf:"varint,3,opt,name=tx_q_len,json=txQLen" json:"tx_q_len,omitempty"`
	Name         string        `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	HardwareAddr []byte        `protobuf:"bytes,5,opt,name=hardware_addr,json=hardwareAddr,proto3" json:"hardware_addr,omitempty"`
	Flags        uint32        `protobuf:"varint,6,opt,name=flags" json:"flags,omitempty"`
	RawFlags     uint32        `protobuf:"varint,7,opt,name=raw_flags,json=rawFlags" json:"raw_flags,omitempty"`
	ParentIndex  int32         `protobuf:"varint,8,opt,name=parent_index,json=parentIndex" json:"parent_index,omitempty"`
	MasterIndex  int32         `protobuf:"varint,9,opt,name=master_index,json=masterIndex" json:"master_index,omitempty"`
	Alias        string        `protobuf:"bytes,10,opt,name=alias" json:"alias,omitempty"`
	Promisc      int32         `protobuf:"varint,11,opt,name=promisc" json:"promisc,omitempty"`
	EncapType    string        `protobuf:"bytes,12,opt,name=encap_type,json=encapType" json:"encap_type,omitempty"`
	OperState    LinkOperState `protobuf:"varint,13,opt,name=oper_state,json=operState,enum=nlaapi.LinkOperState" json:"oper_state,omitempty"`
}

func (m *LinkAttrs) Reset()                    { *m = LinkAttrs{} }
func (m *LinkAttrs) String() string            { return proto.CompactTextString(m) }
func (*LinkAttrs) ProtoMessage()               {}
func (*LinkAttrs) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *LinkAttrs) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *LinkAttrs) GetMtu() int32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *LinkAttrs) GetTxQLen() int32 {
	if m != nil {
		return m.TxQLen
	}
	return 0
}

func (m *LinkAttrs) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LinkAttrs) GetHardwareAddr() []byte {
	if m != nil {
		return m.HardwareAddr
	}
	return nil
}

func (m *LinkAttrs) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *LinkAttrs) GetRawFlags() uint32 {
	if m != nil {
		return m.RawFlags
	}
	return 0
}

func (m *LinkAttrs) GetParentIndex() int32 {
	if m != nil {
		return m.ParentIndex
	}
	return 0
}

func (m *LinkAttrs) GetMasterIndex() int32 {
	if m != nil {
		return m.MasterIndex
	}
	return 0
}

func (m *LinkAttrs) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

func (m *LinkAttrs) GetPromisc() int32 {
	if m != nil {
		return m.Promisc
	}
	return 0
}

func (m *LinkAttrs) GetEncapType() string {
	if m != nil {
		return m.EncapType
	}
	return ""
}

func (m *LinkAttrs) GetOperState() LinkOperState {
	if m != nil {
		return m.OperState
	}
	return LinkOperState_OperUnknown
}

type GenericLinkAttrs struct {
	LinkAttrs *LinkAttrs `protobuf:"bytes,1,opt,name=link_attrs,json=linkAttrs" json:"link_attrs,omitempty"`
}

func (m *GenericLinkAttrs) Reset()                    { *m = GenericLinkAttrs{} }
func (m *GenericLinkAttrs) String() string            { return proto.CompactTextString(m) }
func (*GenericLinkAttrs) ProtoMessage()               {}
func (*GenericLinkAttrs) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *GenericLinkAttrs) GetLinkAttrs() *LinkAttrs {
	if m != nil {
		return m.LinkAttrs
	}
	return nil
}

type DeviceLinkAttrs struct {
	LinkAttrs *LinkAttrs `protobuf:"bytes,1,opt,name=link_attrs,json=linkAttrs" json:"link_attrs,omitempty"`
}

func (m *DeviceLinkAttrs) Reset()                    { *m = DeviceLinkAttrs{} }
func (m *DeviceLinkAttrs) String() string            { return proto.CompactTextString(m) }
func (*DeviceLinkAttrs) ProtoMessage()               {}
func (*DeviceLinkAttrs) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *DeviceLinkAttrs) GetLinkAttrs() *LinkAttrs {
	if m != nil {
		return m.LinkAttrs
	}
	return nil
}

type BridgeLinkAttrs struct {
	LinkAttrs *LinkAttrs `protobuf:"bytes,1,opt,name=link_attrs,json=linkAttrs" json:"link_attrs,omitempty"`
}

func (m *BridgeLinkAttrs) Reset()                    { *m = BridgeLinkAttrs{} }
func (m *BridgeLinkAttrs) String() string            { return proto.CompactTextString(m) }
func (*BridgeLinkAttrs) ProtoMessage()               {}
func (*BridgeLinkAttrs) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *BridgeLinkAttrs) GetLinkAttrs() *LinkAttrs {
	if m != nil {
		return m.LinkAttrs
	}
	return nil
}

type VlanLinkAttrs struct {
	LinkAttrs *LinkAttrs `protobuf:"bytes,1,opt,name=link_attrs,json=linkAttrs" json:"link_attrs,omitempty"`
	VlanId    int32      `protobuf:"varint,2,opt,name=vlan_id,json=vlanId" json:"vlan_id,omitempty"`
}

func (m *VlanLinkAttrs) Reset()                    { *m = VlanLinkAttrs{} }
func (m *VlanLinkAttrs) String() string            { return proto.CompactTextString(m) }
func (*VlanLinkAttrs) ProtoMessage()               {}
func (*VlanLinkAttrs) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *VlanLinkAttrs) GetLinkAttrs() *LinkAttrs {
	if m != nil {
		return m.LinkAttrs
	}
	return nil
}

func (m *VlanLinkAttrs) GetVlanId() int32 {
	if m != nil {
		return m.VlanId
	}
	return 0
}

type VxlanLinkAttrs struct {
	LinkAttrs    *LinkAttrs `protobuf:"bytes,1,opt,name=link_attrs,json=linkAttrs" json:"link_attrs,omitempty"`
	VxlanId      int32      `protobuf:"varint,2,opt,name=vxlan_id,json=vxlanId" json:"vxlan_id,omitempty"`
	VtepDevIndex int32      `protobuf:"varint,3,opt,name=vtep_dev_index,json=vtepDevIndex" json:"vtep_dev_index,omitempty"`
	SrcAddr      []byte     `protobuf:"bytes,4,opt,name=src_addr,json=srcAddr,proto3" json:"src_addr,omitempty"`
	Group        []byte     `protobuf:"bytes,5,opt,name=group,proto3" json:"group,omitempty"`
	Ttl          int32      `protobuf:"varint,6,opt,name=ttl" json:"ttl,omitempty"`
	Tos          int32      `protobuf:"varint,7,opt,name=tos" json:"tos,omitempty"`
	Learning     bool       `protobuf:"varint,8,opt,name=learning" json:"learning,omitempty"`
	Proxy        bool       `protobuf:"varint,9,opt,name=proxy" json:"proxy,omitempty"`
	Rsc          bool       `protobuf:"varint,10,opt,name=rsc" json:"rsc,omitempty"`
	L2Miss       bool       `protobuf:"varint,11,opt,name=l2miss" json:"l2miss,omitempty"`
	L3Miss       bool       `protobuf:"varint,12,opt,name=l3miss" json:"l3miss,omitempty"`
	UdpCSum      bool       `protobuf:"varint,13,opt,name=udp_c_sum,json=udpCSum" json:"udp_c_sum,omitempty"`
	NoAge        bool       `protobuf:"varint,14,opt,name=no_age,json=noAge" json:"no_age,omitempty"`
	Gbp          bool       `protobuf:"varint,15,opt,name=gbp" json:"gbp,omitempty"`
	Age          int32      `protobuf:"varint,16,opt,name=age" json:"age,omitempty"`
	Limit        int32      `protobuf:"varint,17,opt,name=limit" json:"limit,omitempty"`
	Port         int32      `protobuf:"varint,18,opt,name=port" json:"port,omitempty"`
	PortLow      int32      `protobuf:"varint,19,opt,name=port_low,json=portLow" json:"port_low,omitempty"`
	PortHigh     int32      `protobuf:"varint,20,opt,name=port_high,json=portHigh" json:"port_high,omitempty"`
}

func (m *VxlanLinkAttrs) Reset()                    { *m = VxlanLinkAttrs{} }
func (m *VxlanLinkAttrs) String() string            { return proto.CompactTextString(m) }
func (*VxlanLinkAttrs) ProtoMessage()               {}
func (*VxlanLinkAttrs) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *VxlanLinkAttrs) GetLinkAttrs() *LinkAttrs {
	if m != nil {
		return m.LinkAttrs
	}
	return nil
}

func (m *VxlanLinkAttrs) GetVxlanId() int32 {
	if m != nil {
		return m.VxlanId
	}
	return 0
}

func (m *VxlanLinkAttrs) GetVtepDevIndex() int32 {
	if m != nil {
		return m.VtepDevIndex
	}
	return 0
}

func (m *VxlanLinkAttrs) GetSrcAddr() []byte {
	if m != nil {
		return m.SrcAddr
	}
	return nil
}

func (m *VxlanLinkAttrs) GetGroup() []byte {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *VxlanLinkAttrs) GetTtl() int32 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

func (m *VxlanLinkAttrs) GetTos() int32 {
	if m != nil {
		return m.Tos
	}
	return 0
}

func (m *VxlanLinkAttrs) GetLearning() bool {
	if m != nil {
		return m.Learning
	}
	return false
}

func (m *VxlanLinkAttrs) GetProxy() bool {
	if m != nil {
		return m.Proxy
	}
	return false
}

func (m *VxlanLinkAttrs) GetRsc() bool {
	if m != nil {
		return m.Rsc
	}
	return false
}

func (m *VxlanLinkAttrs) GetL2Miss() bool {
	if m != nil {
		return m.L2Miss
	}
	return false
}

func (m *VxlanLinkAttrs) GetL3Miss() bool {
	if m != nil {
		return m.L3Miss
	}
	return false
}

func (m *VxlanLinkAttrs) GetUdpCSum() bool {
	if m != nil {
		return m.UdpCSum
	}
	return false
}

func (m *VxlanLinkAttrs) GetNoAge() bool {
	if m != nil {
		return m.NoAge
	}
	return false
}

func (m *VxlanLinkAttrs) GetGbp() bool {
	if m != nil {
		return m.Gbp
	}
	return false
}

func (m *VxlanLinkAttrs) GetAge() int32 {
	if m != nil {
		return m.Age
	}
	return 0
}

func (m *VxlanLinkAttrs) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *VxlanLinkAttrs) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *VxlanLinkAttrs) GetPortLow() int32 {
	if m != nil {
		return m.PortLow
	}
	return 0
}

func (m *VxlanLinkAttrs) GetPortHigh() int32 {
	if m != nil {
		return m.PortHigh
	}
	return 0
}

type VtiLinkAttrs struct {
	LinkAttrs *LinkAttrs `protobuf:"bytes,1,opt,name=link_attrs,json=linkAttrs" json:"link_attrs,omitempty"`
	IKey      uint32     `protobuf:"varint,2,opt,name=i_key,json=iKey" json:"i_key,omitempty"`
	OKey      uint32     `protobuf:"varint,3,opt,name=o_key,json=oKey" json:"o_key,omitempty"`
	Link      uint32     `protobuf:"varint,4,opt,name=link" json:"link,omitempty"`
	Local     []byte     `protobuf:"bytes,5,opt,name=local,proto3" json:"local,omitempty"`
	Remote    []byte     `protobuf:"bytes,6,opt,name=remote,proto3" json:"remote,omitempty"`
}

func (m *VtiLinkAttrs) Reset()                    { *m = VtiLinkAttrs{} }
func (m *VtiLinkAttrs) String() string            { return proto.CompactTextString(m) }
func (*VtiLinkAttrs) ProtoMessage()               {}
func (*VtiLinkAttrs) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *VtiLinkAttrs) GetLinkAttrs() *LinkAttrs {
	if m != nil {
		return m.LinkAttrs
	}
	return nil
}

func (m *VtiLinkAttrs) GetIKey() uint32 {
	if m != nil {
		return m.IKey
	}
	return 0
}

func (m *VtiLinkAttrs) GetOKey() uint32 {
	if m != nil {
		return m.OKey
	}
	return 0
}

func (m *VtiLinkAttrs) GetLink() uint32 {
	if m != nil {
		return m.Link
	}
	return 0
}

func (m *VtiLinkAttrs) GetLocal() []byte {
	if m != nil {
		return m.Local
	}
	return nil
}

func (m *VtiLinkAttrs) GetRemote() []byte {
	if m != nil {
		return m.Remote
	}
	return nil
}

type VethLinkAttrs struct {
	LinkAttrs *LinkAttrs `protobuf:"bytes,1,opt,name=link_attrs,json=linkAttrs" json:"link_attrs,omitempty"`
	PeerName  string     `protobuf:"bytes,2,opt,name=peer_name,json=peerName" json:"peer_name,omitempty"`
}

func (m *VethLinkAttrs) Reset()                    { *m = VethLinkAttrs{} }
func (m *VethLinkAttrs) String() string            { return proto.CompactTextString(m) }
func (*VethLinkAttrs) ProtoMessage()               {}
func (*VethLinkAttrs) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

func (m *VethLinkAttrs) GetLinkAttrs() *LinkAttrs {
	if m != nil {
		return m.LinkAttrs
	}
	return nil
}

func (m *VethLinkAttrs) GetPeerName() string {
	if m != nil {
		return m.PeerName
	}
	return ""
}

type BondAdInfo struct {
	AggregatorId int32  `protobuf:"varint,1,opt,name=aggregator_id,json=aggregatorId" json:"aggregator_id,omitempty"`
	NumPorts     int32  `protobuf:"varint,2,opt,name=num_ports,json=numPorts" json:"num_ports,omitempty"`
	ActorKey     int32  `protobuf:"varint,3,opt,name=actor_key,json=actorKey" json:"actor_key,omitempty"`
	PartnerKey   int32  `protobuf:"varint,4,opt,name=partner_key,json=partnerKey" json:"partner_key,omitempty"`
	PartnerMac   []byte `protobuf:"bytes,5,opt,name=partner_mac,json=partnerMac,proto3" json:"partner_mac,omitempty"`
}

func (m *BondAdInfo) Reset()                    { *m = BondAdInfo{} }
func (m *BondAdInfo) String() string            { return proto.CompactTextString(m) }
func (*BondAdInfo) ProtoMessage()               {}
func (*BondAdInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

func (m *BondAdInfo) GetAggregatorId() int32 {
	if m != nil {
		return m.AggregatorId
	}
	return 0
}

func (m *BondAdInfo) GetNumPorts() int32 {
	if m != nil {
		return m.NumPorts
	}
	return 0
}

func (m *BondAdInfo) GetActorKey() int32 {
	if m != nil {
		return m.ActorKey
	}
	return 0
}

func (m *BondAdInfo) GetPartnerKey() int32 {
	if m != nil {
		return m.PartnerKey
	}
	return 0
}

func (m *BondAdInfo) GetPartnerMac() []byte {
	if m != nil {
		return m.PartnerMac
	}
	return nil
}

type BondLinkAttrs struct {
	LinkAttrs       *LinkAttrs          `protobuf:"bytes,1,opt,name=link_attrs,json=linkAttrs" json:"link_attrs,omitempty"`
	Mode            BondMode            `protobuf:"varint,2,opt,name=mode,enum=nlaapi.BondMode" json:"mode,omitempty"`
	ActiveSlave     int32               `protobuf:"varint,3,opt,name=active_slave,json=activeSlave" json:"active_slave,omitempty"`
	Miimon          int32               `protobuf:"varint,4,opt,name=miimon" json:"miimon,omitempty"`
	UpDelay         int32               `protobuf:"varint,5,opt,name=up_delay,json=upDelay" json:"up_delay,omitempty"`
	DownDelay       int32               `protobuf:"varint,6,opt,name=down_delay,json=downDelay" json:"down_delay,omitempty"`
	UseCarrier      int32               `protobuf:"varint,7,opt,name=use_carrier,json=useCarrier" json:"use_carrier,omitempty"`
	ArpInterval     int32               `protobuf:"varint,8,opt,name=arp_interval,json=arpInterval" json:"arp_interval,omitempty"`
	ArpIpTargets    [][]byte            `protobuf:"bytes,9,rep,name=arp_ip_targets,json=arpIpTargets,proto3" json:"arp_ip_targets,omitempty"`
	ArpValidate     BondArpValidate     `protobuf:"varint,10,opt,name=arp_validate,json=arpValidate,enum=nlaapi.BondArpValidate" json:"arp_validate,omitempty"`
	ArpAllTargets   BondArpAllTargets   `protobuf:"varint,11,opt,name=arp_all_targets,json=arpAllTargets,enum=nlaapi.BondArpAllTargets" json:"arp_all_targets,omitempty"`
	Primary         int32               `protobuf:"varint,12,opt,name=primary" json:"primary,omitempty"`
	PrimaryReselect BondPrimaryReselect `protobuf:"varint,13,opt,name=primary_reselect,json=primaryReselect,enum=nlaapi.BondPrimaryReselect" json:"primary_reselect,omitempty"`
	FailOverMac     BondFailOverMac     `protobuf:"varint,14,opt,name=fail_over_mac,json=failOverMac,enum=nlaapi.BondFailOverMac" json:"fail_over_mac,omitempty"`
	XmitHashPolicy  BondXmitHashPolicy  `protobuf:"varint,15,opt,name=xmit_hash_policy,json=xmitHashPolicy,enum=nlaapi.BondXmitHashPolicy" json:"xmit_hash_policy,omitempty"`
	ResendIgmp      int32               `protobuf:"varint,16,opt,name=resend_igmp,json=resendIgmp" json:"resend_igmp,omitempty"`
	NumPeerNotif    int32               `protobuf:"varint,17,opt,name=num_peer_notif,json=numPeerNotif" json:"num_peer_notif,omitempty"`
	AllSlavesActive int32               `protobuf:"varint,18,opt,name=all_slaves_active,json=allSlavesActive" json:"all_slaves_active,omitempty"`
	MinLinks        int32               `protobuf:"varint,19,opt,name=min_links,json=minLinks" json:"min_links,omitempty"`
	LpInterval      int32               `protobuf:"varint,20,opt,name=lp_interval,json=lpInterval" json:"lp_interval,omitempty"`
	PackersPerSlave int32               `protobuf:"varint,21,opt,name=packers_per_slave,json=packersPerSlave" json:"packers_per_slave,omitempty"`
	LacpRate        BondLacpRate        `protobuf:"varint,22,opt,name=lacp_rate,json=lacpRate,enum=nlaapi.BondLacpRate" json:"lacp_rate,omitempty"`
	AdSelect        BondAdSelect        `protobuf:"varint,23,opt,name=ad_select,json=adSelect,enum=nlaapi.BondAdSelect" json:"ad_select,omitempty"`
	AdInfo          *BondAdInfo         `protobuf:"bytes,24,opt,name=ad_info,json=adInfo" json:"ad_info,omitempty"`
}

func (m *BondLinkAttrs) Reset()                    { *m = BondLinkAttrs{} }
func (m *BondLinkAttrs) String() string            { return proto.CompactTextString(m) }
func (*BondLinkAttrs) ProtoMessage()               {}
func (*BondLinkAttrs) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37} }

func (m *BondLinkAttrs) GetLinkAttrs() *LinkAttrs {
	if m != nil {
		return m.LinkAttrs
	}
	return nil
}

func (m *BondLinkAttrs) GetMode() BondMode {
	if m != nil {
		return m.Mode
	}
	return BondMode_BOND_MODE_BALANCE_RR
}

func (m *BondLinkAttrs) GetActiveSlave() int32 {
	if m != nil {
		return m.ActiveSlave
	}
	return 0
}

func (m *BondLinkAttrs) GetMiimon() int32 {
	if m != nil {
		return m.Miimon
	}
	return 0
}

func (m *BondLinkAttrs) GetUpDelay() int32 {
	if m != nil {
		return m.UpDelay
	}
	return 0
}

func (m *BondLinkAttrs) GetDownDelay() int32 {
	if m != nil {
		return m.DownDelay
	}
	return 0
}

func (m *BondLinkAttrs) GetUseCarrier() int32 {
	if m != nil {
		return m.UseCarrier
	}
	return 0
}

func (m *BondLinkAttrs) GetArpInterval() int32 {
	if m != nil {
		return m.ArpInterval
	}
	return 0
}

func (m *BondLinkAttrs) GetArpIpTargets() [][]byte {
	if m != nil {
		return m.ArpIpTargets
	}
	return nil
}

func (m *BondLinkAttrs) GetArpValidate() BondArpValidate {
	if m != nil {
		return m.ArpValidate
	}
	return BondArpValidate_BOND_ARP_VALIDATE_NONE
}

func (m *BondLinkAttrs) GetArpAllTargets() BondArpAllTargets {
	if m != nil {
		return m.ArpAllTargets
	}
	return BondArpAllTargets_BOND_ARP_ALL_TARGETS_ANY
}

func (m *BondLinkAttrs) GetPrimary() int32 {
	if m != nil {
		return m.Primary
	}
	return 0
}

func (m *BondLinkAttrs) GetPrimaryReselect() BondPrimaryReselect {
	if m != nil {
		return m.PrimaryReselect
	}
	return BondPrimaryReselect_BOND_PRIMARY_RESELECT_ALWAYS
}

func (m *BondLinkAttrs) GetFailOverMac() BondFailOverMac {
	if m != nil {
		return m.FailOverMac
	}
	return BondFailOverMac_BOND_FAIL_OVER_MAC_NONE
}

func (m *BondLinkAttrs) GetXmitHashPolicy() BondXmitHashPolicy {
	if m != nil {
		return m.XmitHashPolicy
	}
	return BondXmitHashPolicy_BOND_XMIT_HASH_POLICY_LAYER2
}

func (m *BondLinkAttrs) GetResendIgmp() int32 {
	if m != nil {
		return m.ResendIgmp
	}
	return 0
}

func (m *BondLinkAttrs) GetNumPeerNotif() int32 {
	if m != nil {
		return m.NumPeerNotif
	}
	return 0
}

func (m *BondLinkAttrs) GetAllSlavesActive() int32 {
	if m != nil {
		return m.AllSlavesActive
	}
	return 0
}

func (m *BondLinkAttrs) GetMinLinks() int32 {
	if m != nil {
		return m.MinLinks
	}
	return 0
}

func (m *BondLinkAttrs) GetLpInterval() int32 {
	if m != nil {
		return m.LpInterval
	}
	return 0
}

func (m *BondLinkAttrs) GetPackersPerSlave() int32 {
	if m != nil {
		return m.PackersPerSlave
	}
	return 0
}

func (m *BondLinkAttrs) GetLacpRate() BondLacpRate {
	if m != nil {
		return m.LacpRate
	}
	return BondLacpRate_BOND_LACP_RATE_SLOW
}

func (m *BondLinkAttrs) GetAdSelect() BondAdSelect {
	if m != nil {
		return m.AdSelect
	}
	return BondAdSelect_BOND_AD_SELECT_STABLE
}

func (m *BondLinkAttrs) GetAdInfo() *BondAdInfo {
	if m != nil {
		return m.AdInfo
	}
	return nil
}

type Link struct {
	Type string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	// Types that are valid to be assigned to LinkAttrs:
	//	*Link_Device
	//	*Link_Bridge
	//	*Link_Vlan
	//	*Link_Vxlan
	//	*Link_Vti
	//	*Link_Veth
	//	*Link_Bond
	//	*Link_Generic
	LinkAttrs isLink_LinkAttrs `protobuf_oneof:"link_attrs"`
	NId       uint32           `protobuf:"varint,10,opt,name=n_id,json=nId" json:"n_id,omitempty"`
	LnId      uint32           `protobuf:"varint,11,opt,name=ln_id,json=lnId" json:"ln_id,omitempty"`
}

func (m *Link) Reset()                    { *m = Link{} }
func (m *Link) String() string            { return proto.CompactTextString(m) }
func (*Link) ProtoMessage()               {}
func (*Link) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38} }

type isLink_LinkAttrs interface {
	isLink_LinkAttrs()
}

type Link_Device struct {
	Device *DeviceLinkAttrs `protobuf:"bytes,2,opt,name=device,oneof"`
}
type Link_Bridge struct {
	Bridge *BridgeLinkAttrs `protobuf:"bytes,3,opt,name=bridge,oneof"`
}
type Link_Vlan struct {
	Vlan *VlanLinkAttrs `protobuf:"bytes,4,opt,name=vlan,oneof"`
}
type Link_Vxlan struct {
	Vxlan *VxlanLinkAttrs `protobuf:"bytes,5,opt,name=vxlan,oneof"`
}
type Link_Vti struct {
	Vti *VtiLinkAttrs `protobuf:"bytes,6,opt,name=vti,oneof"`
}
type Link_Veth struct {
	Veth *VethLinkAttrs `protobuf:"bytes,7,opt,name=veth,oneof"`
}
type Link_Bond struct {
	Bond *BondLinkAttrs `protobuf:"bytes,8,opt,name=bond,oneof"`
}
type Link_Generic struct {
	Generic *GenericLinkAttrs `protobuf:"bytes,9,opt,name=generic,oneof"`
}

func (*Link_Device) isLink_LinkAttrs()  {}
func (*Link_Bridge) isLink_LinkAttrs()  {}
func (*Link_Vlan) isLink_LinkAttrs()    {}
func (*Link_Vxlan) isLink_LinkAttrs()   {}
func (*Link_Vti) isLink_LinkAttrs()     {}
func (*Link_Veth) isLink_LinkAttrs()    {}
func (*Link_Bond) isLink_LinkAttrs()    {}
func (*Link_Generic) isLink_LinkAttrs() {}

func (m *Link) GetLinkAttrs() isLink_LinkAttrs {
	if m != nil {
		return m.LinkAttrs
	}
	return nil
}

func (m *Link) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Link) GetDevice() *DeviceLinkAttrs {
	if x, ok := m.GetLinkAttrs().(*Link_Device); ok {
		return x.Device
	}
	return nil
}

func (m *Link) GetBridge() *BridgeLinkAttrs {
	if x, ok := m.GetLinkAttrs().(*Link_Bridge); ok {
		return x.Bridge
	}
	return nil
}

func (m *Link) GetVlan() *VlanLinkAttrs {
	if x, ok := m.GetLinkAttrs().(*Link_Vlan); ok {
		return x.Vlan
	}
	return nil
}

func (m *Link) GetVxlan() *VxlanLinkAttrs {
	if x, ok := m.GetLinkAttrs().(*Link_Vxlan); ok {
		return x.Vxlan
	}
	return nil
}

func (m *Link) GetVti() *VtiLinkAttrs {
	if x, ok := m.GetLinkAttrs().(*Link_Vti); ok {
		return x.Vti
	}
	return nil
}

func (m *Link) GetVeth() *VethLinkAttrs {
	if x, ok := m.GetLinkAttrs().(*Link_Veth); ok {
		return x.Veth
	}
	return nil
}

func (m *Link) GetBond() *BondLinkAttrs {
	if x, ok := m.GetLinkAttrs().(*Link_Bond); ok {
		return x.Bond
	}
	return nil
}

func (m *Link) GetGeneric() *GenericLinkAttrs {
	if x, ok := m.GetLinkAttrs().(*Link_Generic); ok {
		return x.Generic
	}
	return nil
}

func (m *Link) GetNId() uint32 {
	if m != nil {
		return m.NId
	}
	return 0
}

func (m *Link) GetLnId() uint32 {
	if m != nil {
		return m.LnId
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Link) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Link_OneofMarshaler, _Link_OneofUnmarshaler, _Link_OneofSizer, []interface{}{
		(*Link_Device)(nil),
		(*Link_Bridge)(nil),
		(*Link_Vlan)(nil),
		(*Link_Vxlan)(nil),
		(*Link_Vti)(nil),
		(*Link_Veth)(nil),
		(*Link_Bond)(nil),
		(*Link_Generic)(nil),
	}
}

func _Link_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Link)
	// link_attrs
	switch x := m.LinkAttrs.(type) {
	case *Link_Device:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Device); err != nil {
			return err
		}
	case *Link_Bridge:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Bridge); err != nil {
			return err
		}
	case *Link_Vlan:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Vlan); err != nil {
			return err
		}
	case *Link_Vxlan:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Vxlan); err != nil {
			return err
		}
	case *Link_Vti:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Vti); err != nil {
			return err
		}
	case *Link_Veth:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Veth); err != nil {
			return err
		}
	case *Link_Bond:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Bond); err != nil {
			return err
		}
	case *Link_Generic:
		b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Generic); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Link.LinkAttrs has unexpected type %T", x)
	}
	return nil
}

func _Link_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Link)
	switch tag {
	case 2: // link_attrs.device
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DeviceLinkAttrs)
		err := b.DecodeMessage(msg)
		m.LinkAttrs = &Link_Device{msg}
		return true, err
	case 3: // link_attrs.bridge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BridgeLinkAttrs)
		err := b.DecodeMessage(msg)
		m.LinkAttrs = &Link_Bridge{msg}
		return true, err
	case 4: // link_attrs.vlan
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VlanLinkAttrs)
		err := b.DecodeMessage(msg)
		m.LinkAttrs = &Link_Vlan{msg}
		return true, err
	case 5: // link_attrs.vxlan
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VxlanLinkAttrs)
		err := b.DecodeMessage(msg)
		m.LinkAttrs = &Link_Vxlan{msg}
		return true, err
	case 6: // link_attrs.vti
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VtiLinkAttrs)
		err := b.DecodeMessage(msg)
		m.LinkAttrs = &Link_Vti{msg}
		return true, err
	case 7: // link_attrs.veth
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VethLinkAttrs)
		err := b.DecodeMessage(msg)
		m.LinkAttrs = &Link_Veth{msg}
		return true, err
	case 8: // link_attrs.bond
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BondLinkAttrs)
		err := b.DecodeMessage(msg)
		m.LinkAttrs = &Link_Bond{msg}
		return true, err
	case 9: // link_attrs.generic
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GenericLinkAttrs)
		err := b.DecodeMessage(msg)
		m.LinkAttrs = &Link_Generic{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Link_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Link)
	// link_attrs
	switch x := m.LinkAttrs.(type) {
	case *Link_Device:
		s := proto.Size(x.Device)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Link_Bridge:
		s := proto.Size(x.Bridge)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Link_Vlan:
		s := proto.Size(x.Vlan)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Link_Vxlan:
		s := proto.Size(x.Vxlan)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Link_Vti:
		s := proto.Size(x.Vti)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Link_Veth:
		s := proto.Size(x.Veth)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Link_Bond:
		s := proto.Size(x.Bond)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Link_Generic:
		s := proto.Size(x.Generic)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Addr struct {
	Ip        []byte `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip,omitempty"`
	IpMask    []byte `protobuf:"bytes,2,opt,name=ip_mask,json=ipMask,proto3" json:"ip_mask,omitempty"`
	Label     string `protobuf:"bytes,3,opt,name=label" json:"label,omitempty"`
	Flags     int32  `protobuf:"varint,4,opt,name=flags" json:"flags,omitempty"`
	Scope     int32  `protobuf:"varint,5,opt,name=scope" json:"scope,omitempty"`
	Peer      []byte `protobuf:"bytes,6,opt,name=peer,proto3" json:"peer,omitempty"`
	PeerMask  []byte `protobuf:"bytes,7,opt,name=peer_mask,json=peerMask,proto3" json:"peer_mask,omitempty"`
	Broadcast []byte `protobuf:"bytes,8,opt,name=broadcast,proto3" json:"broadcast,omitempty"`
	Index     int32  `protobuf:"varint,9,opt,name=index" json:"index,omitempty"`
	Family    int32  `protobuf:"varint,10,opt,name=family" json:"family,omitempty"`
	NId       uint32 `protobuf:"varint,11,opt,name=n_id,json=nId" json:"n_id,omitempty"`
	AdId      uint32 `protobuf:"varint,12,opt,name=ad_id,json=adId" json:"ad_id,omitempty"`
}

func (m *Addr) Reset()                    { *m = Addr{} }
func (m *Addr) String() string            { return proto.CompactTextString(m) }
func (*Addr) ProtoMessage()               {}
func (*Addr) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{39} }

func (m *Addr) GetIp() []byte {
	if m != nil {
		return m.Ip
	}
	return nil
}

func (m *Addr) GetIpMask() []byte {
	if m != nil {
		return m.IpMask
	}
	return nil
}

func (m *Addr) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *Addr) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *Addr) GetScope() int32 {
	if m != nil {
		return m.Scope
	}
	return 0
}

func (m *Addr) GetPeer() []byte {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *Addr) GetPeerMask() []byte {
	if m != nil {
		return m.PeerMask
	}
	return nil
}

func (m *Addr) GetBroadcast() []byte {
	if m != nil {
		return m.Broadcast
	}
	return nil
}

func (m *Addr) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Addr) GetFamily() int32 {
	if m != nil {
		return m.Family
	}
	return 0
}

func (m *Addr) GetNId() uint32 {
	if m != nil {
		return m.NId
	}
	return 0
}

func (m *Addr) GetAdId() uint32 {
	if m != nil {
		return m.AdId
	}
	return 0
}

type Neigh struct {
	LinkIndex    int32  `protobuf:"varint,1,opt,name=link_index,json=linkIndex" json:"link_index,omitempty"`
	Family       int32  `protobuf:"varint,2,opt,name=family" json:"family,omitempty"`
	State        int32  `protobuf:"varint,3,opt,name=state" json:"state,omitempty"`
	Type         int32  `protobuf:"varint,4,opt,name=type" json:"type,omitempty"`
	Flags        int32  `protobuf:"varint,5,opt,name=flags" json:"flags,omitempty"`
	Ip           []byte `protobuf:"bytes,6,opt,name=ip,proto3" json:"ip,omitempty"`
	HardwareAddr []byte `protobuf:"bytes,7,opt,name=hardware_addr,json=hardwareAddr,proto3" json:"hardware_addr,omitempty"`
	NId          uint32 `protobuf:"varint,8,opt,name=n_id,json=nId" json:"n_id,omitempty"`
	NeId         uint32 `protobuf:"varint,9,opt,name=ne_id,json=neId" json:"ne_id,omitempty"`
}

func (m *Neigh) Reset()                    { *m = Neigh{} }
func (m *Neigh) String() string            { return proto.CompactTextString(m) }
func (*Neigh) ProtoMessage()               {}
func (*Neigh) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{40} }

func (m *Neigh) GetLinkIndex() int32 {
	if m != nil {
		return m.LinkIndex
	}
	return 0
}

func (m *Neigh) GetFamily() int32 {
	if m != nil {
		return m.Family
	}
	return 0
}

func (m *Neigh) GetState() int32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *Neigh) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Neigh) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *Neigh) GetIp() []byte {
	if m != nil {
		return m.Ip
	}
	return nil
}

func (m *Neigh) GetHardwareAddr() []byte {
	if m != nil {
		return m.HardwareAddr
	}
	return nil
}

func (m *Neigh) GetNId() uint32 {
	if m != nil {
		return m.NId
	}
	return 0
}

func (m *Neigh) GetNeId() uint32 {
	if m != nil {
		return m.NeId
	}
	return 0
}

type NexthopInfo struct {
	LinkIndex int32        `protobuf:"varint,1,opt,name=link_index,json=linkIndex" json:"link_index,omitempty"`
	Hops      int32        `protobuf:"varint,2,opt,name=hops" json:"hops,omitempty"`
	Gw        []byte       `protobuf:"bytes,3,opt,name=gw,proto3" json:"gw,omitempty"`
	Flags     int32        `protobuf:"varint,4,opt,name=flags" json:"flags,omitempty"`
	NewDst    *Destination `protobuf:"bytes,5,opt,name=new_dst,json=newDst" json:"new_dst,omitempty"`
	Encap     *Encap       `protobuf:"bytes,6,opt,name=encap" json:"encap,omitempty"`
}

func (m *NexthopInfo) Reset()                    { *m = NexthopInfo{} }
func (m *NexthopInfo) String() string            { return proto.CompactTextString(m) }
func (*NexthopInfo) ProtoMessage()               {}
func (*NexthopInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{41} }

func (m *NexthopInfo) GetLinkIndex() int32 {
	if m != nil {
		return m.LinkIndex
	}
	return 0
}

func (m *NexthopInfo) GetHops() int32 {
	if m != nil {
		return m.Hops
	}
	return 0
}

func (m *NexthopInfo) GetGw() []byte {
	if m != nil {
		return m.Gw
	}
	return nil
}

func (m *NexthopInfo) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *NexthopInfo) GetNewDst() *Destination {
	if m != nil {
		return m.NewDst
	}
	return nil
}

func (m *NexthopInfo) GetEncap() *Encap {
	if m != nil {
		return m.Encap
	}
	return nil
}

type MPLSDestination struct {
	Labels []uint32 `protobuf:"varint,1,rep,packed,name=labels" json:"labels,omitempty"`
}

func (m *MPLSDestination) Reset()                    { *m = MPLSDestination{} }
func (m *MPLSDestination) String() string            { return proto.CompactTextString(m) }
func (*MPLSDestination) ProtoMessage()               {}
func (*MPLSDestination) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{42} }

func (m *MPLSDestination) GetLabels() []uint32 {
	if m != nil {
		return m.Labels
	}
	return nil
}

type Destination struct {
	Family int32 `protobuf:"varint,1,opt,name=family" json:"family,omitempty"`
	// Types that are valid to be assigned to Dest:
	//	*Destination_Mpls
	Dest isDestination_Dest `protobuf_oneof:"dest"`
}

func (m *Destination) Reset()                    { *m = Destination{} }
func (m *Destination) String() string            { return proto.CompactTextString(m) }
func (*Destination) ProtoMessage()               {}
func (*Destination) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{43} }

type isDestination_Dest interface {
	isDestination_Dest()
}

type Destination_Mpls struct {
	Mpls *MPLSDestination `protobuf:"bytes,2,opt,name=mpls,oneof"`
}

func (*Destination_Mpls) isDestination_Dest() {}

func (m *Destination) GetDest() isDestination_Dest {
	if m != nil {
		return m.Dest
	}
	return nil
}

func (m *Destination) GetFamily() int32 {
	if m != nil {
		return m.Family
	}
	return 0
}

func (m *Destination) GetMpls() *MPLSDestination {
	if x, ok := m.GetDest().(*Destination_Mpls); ok {
		return x.Mpls
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Destination) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Destination_OneofMarshaler, _Destination_OneofUnmarshaler, _Destination_OneofSizer, []interface{}{
		(*Destination_Mpls)(nil),
	}
}

func _Destination_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Destination)
	// dest
	switch x := m.Dest.(type) {
	case *Destination_Mpls:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Mpls); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Destination.Dest has unexpected type %T", x)
	}
	return nil
}

func _Destination_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Destination)
	switch tag {
	case 2: // dest.mpls
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MPLSDestination)
		err := b.DecodeMessage(msg)
		m.Dest = &Destination_Mpls{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Destination_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Destination)
	// dest
	switch x := m.Dest.(type) {
	case *Destination_Mpls:
		s := proto.Size(x.Mpls)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type MPLSEncap struct {
	Labels []uint32 `protobuf:"varint,1,rep,packed,name=labels" json:"labels,omitempty"`
}

func (m *MPLSEncap) Reset()                    { *m = MPLSEncap{} }
func (m *MPLSEncap) String() string            { return proto.CompactTextString(m) }
func (*MPLSEncap) ProtoMessage()               {}
func (*MPLSEncap) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{44} }

func (m *MPLSEncap) GetLabels() []uint32 {
	if m != nil {
		return m.Labels
	}
	return nil
}

type Encap struct {
	Type uint32 `protobuf:"varint,1,opt,name=type" json:"type,omitempty"`
	// Types that are valid to be assigned to Encap:
	//	*Encap_Mpls
	Encap isEncap_Encap `protobuf_oneof:"encap"`
}

func (m *Encap) Reset()                    { *m = Encap{} }
func (m *Encap) String() string            { return proto.CompactTextString(m) }
func (*Encap) ProtoMessage()               {}
func (*Encap) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{45} }

type isEncap_Encap interface {
	isEncap_Encap()
}

type Encap_Mpls struct {
	Mpls *MPLSEncap `protobuf:"bytes,2,opt,name=mpls,oneof"`
}

func (*Encap_Mpls) isEncap_Encap() {}

func (m *Encap) GetEncap() isEncap_Encap {
	if m != nil {
		return m.Encap
	}
	return nil
}

func (m *Encap) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Encap) GetMpls() *MPLSEncap {
	if x, ok := m.GetEncap().(*Encap_Mpls); ok {
		return x.Mpls
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Encap) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Encap_OneofMarshaler, _Encap_OneofUnmarshaler, _Encap_OneofSizer, []interface{}{
		(*Encap_Mpls)(nil),
	}
}

func _Encap_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Encap)
	// encap
	switch x := m.Encap.(type) {
	case *Encap_Mpls:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Mpls); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Encap.Encap has unexpected type %T", x)
	}
	return nil
}

func _Encap_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Encap)
	switch tag {
	case 2: // encap.mpls
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MPLSEncap)
		err := b.DecodeMessage(msg)
		m.Encap = &Encap_Mpls{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Encap_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Encap)
	// encap
	switch x := m.Encap.(type) {
	case *Encap_Mpls:
		s := proto.Size(x.Mpls)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type EncapInfoKey struct {
	Dst string `protobuf:"bytes,1,opt,name=dst" json:"dst,omitempty"`
	Vrf uint32 `protobuf:"varint,2,opt,name=vrf" json:"vrf,omitempty"`
}

func (m *EncapInfoKey) Reset()                    { *m = EncapInfoKey{} }
func (m *EncapInfoKey) String() string            { return proto.CompactTextString(m) }
func (*EncapInfoKey) ProtoMessage()               {}
func (*EncapInfoKey) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{46} }

func (m *EncapInfoKey) GetDst() string {
	if m != nil {
		return m.Dst
	}
	return ""
}

func (m *EncapInfoKey) GetVrf() uint32 {
	if m != nil {
		return m.Vrf
	}
	return 0
}

type EncapInfo struct {
	Ip   []byte `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip,omitempty"`
	Mask []byte `protobuf:"bytes,2,opt,name=mask,proto3" json:"mask,omitempty"`
	Vrf  uint32 `protobuf:"varint,3,opt,name=vrf" json:"vrf,omitempty"`
	EnId uint32 `protobuf:"varint,4,opt,name=en_id,json=enId" json:"en_id,omitempty"`
}

func (m *EncapInfo) Reset()                    { *m = EncapInfo{} }
func (m *EncapInfo) String() string            { return proto.CompactTextString(m) }
func (*EncapInfo) ProtoMessage()               {}
func (*EncapInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{47} }

func (m *EncapInfo) GetIp() []byte {
	if m != nil {
		return m.Ip
	}
	return nil
}

func (m *EncapInfo) GetMask() []byte {
	if m != nil {
		return m.Mask
	}
	return nil
}

func (m *EncapInfo) GetVrf() uint32 {
	if m != nil {
		return m.Vrf
	}
	return 0
}

func (m *EncapInfo) GetEnId() uint32 {
	if m != nil {
		return m.EnId
	}
	return 0
}

type Route struct {
	LinkIndex  int32          `protobuf:"varint,1,opt,name=link_index,json=linkIndex" json:"link_index,omitempty"`
	ILinkIndex int32          `protobuf:"varint,2,opt,name=i_link_index,json=iLinkIndex" json:"i_link_index,omitempty"`
	Scope      int32          `protobuf:"varint,3,opt,name=scope" json:"scope,omitempty"`
	Dst        []byte         `protobuf:"bytes,4,opt,name=dst,proto3" json:"dst,omitempty"`
	DstMask    []byte         `protobuf:"bytes,5,opt,name=dst_mask,json=dstMask,proto3" json:"dst_mask,omitempty"`
	Src        []byte         `protobuf:"bytes,6,opt,name=src,proto3" json:"src,omitempty"`
	Gw         []byte         `protobuf:"bytes,7,opt,name=gw,proto3" json:"gw,omitempty"`
	MultiPath  []*NexthopInfo `protobuf:"bytes,8,rep,name=multi_path,json=multiPath" json:"multi_path,omitempty"`
	Protocol   int32          `protobuf:"varint,9,opt,name=protocol" json:"protocol,omitempty"`
	Priority   int32          `protobuf:"varint,10,opt,name=priority" json:"priority,omitempty"`
	Table      int32          `protobuf:"varint,11,opt,name=table" json:"table,omitempty"`
	Type       int32          `protobuf:"varint,12,opt,name=type" json:"type,omitempty"`
	Tos        int32          `protobuf:"varint,13,opt,name=tos" json:"tos,omitempty"`
	Flags      int32          `protobuf:"varint,14,opt,name=flags" json:"flags,omitempty"`
	MplsDst    int32          `protobuf:"varint,15,opt,name=mpls_dst,json=mplsDst" json:"mpls_dst,omitempty"`
	NewDst     *Destination   `protobuf:"bytes,16,opt,name=new_dst,json=newDst" json:"new_dst,omitempty"`
	Encap      *Encap         `protobuf:"bytes,17,opt,name=encap" json:"encap,omitempty"`
	NId        uint32         `protobuf:"varint,18,opt,name=n_id,json=nId" json:"n_id,omitempty"`
	RtId       uint32         `protobuf:"varint,19,opt,name=rt_id,json=rtId" json:"rt_id,omitempty"`
	VpnGw      []byte         `protobuf:"bytes,20,opt,name=vpn_gw,json=vpnGw,proto3" json:"vpn_gw,omitempty"`
	EnIds      []uint32       `protobuf:"varint,21,rep,packed,name=en_ids,json=enIds" json:"en_ids,omitempty"`
}

func (m *Route) Reset()                    { *m = Route{} }
func (m *Route) String() string            { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()               {}
func (*Route) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{48} }

func (m *Route) GetLinkIndex() int32 {
	if m != nil {
		return m.LinkIndex
	}
	return 0
}

func (m *Route) GetILinkIndex() int32 {
	if m != nil {
		return m.ILinkIndex
	}
	return 0
}

func (m *Route) GetScope() int32 {
	if m != nil {
		return m.Scope
	}
	return 0
}

func (m *Route) GetDst() []byte {
	if m != nil {
		return m.Dst
	}
	return nil
}

func (m *Route) GetDstMask() []byte {
	if m != nil {
		return m.DstMask
	}
	return nil
}

func (m *Route) GetSrc() []byte {
	if m != nil {
		return m.Src
	}
	return nil
}

func (m *Route) GetGw() []byte {
	if m != nil {
		return m.Gw
	}
	return nil
}

func (m *Route) GetMultiPath() []*NexthopInfo {
	if m != nil {
		return m.MultiPath
	}
	return nil
}

func (m *Route) GetProtocol() int32 {
	if m != nil {
		return m.Protocol
	}
	return 0
}

func (m *Route) GetPriority() int32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *Route) GetTable() int32 {
	if m != nil {
		return m.Table
	}
	return 0
}

func (m *Route) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Route) GetTos() int32 {
	if m != nil {
		return m.Tos
	}
	return 0
}

func (m *Route) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *Route) GetMplsDst() int32 {
	if m != nil {
		return m.MplsDst
	}
	return 0
}

func (m *Route) GetNewDst() *Destination {
	if m != nil {
		return m.NewDst
	}
	return nil
}

func (m *Route) GetEncap() *Encap {
	if m != nil {
		return m.Encap
	}
	return nil
}

func (m *Route) GetNId() uint32 {
	if m != nil {
		return m.NId
	}
	return 0
}

func (m *Route) GetRtId() uint32 {
	if m != nil {
		return m.RtId
	}
	return 0
}

func (m *Route) GetVpnGw() []byte {
	if m != nil {
		return m.VpnGw
	}
	return nil
}

func (m *Route) GetEnIds() []uint32 {
	if m != nil {
		return m.EnIds
	}
	return nil
}

func init() {
	proto.RegisterType((*NlMsghdr)(nil), "nlaapi.NlMsghdr")
	proto.RegisterType((*NetlinkMessage)(nil), "nlaapi.NetlinkMessage")
	proto.RegisterType((*NetlinkMessageReply)(nil), "nlaapi.NetlinkMessageReply")
	proto.RegisterType((*MonNetlinkRequest)(nil), "nlaapi.MonNetlinkRequest")
	proto.RegisterType((*NlMsgUni)(nil), "nlaapi.NlMsgUni")
	proto.RegisterType((*NetlinkMessageUnion)(nil), "nlaapi.NetlinkMessageUnion")
	proto.RegisterType((*ModVpnRequest)(nil), "nlaapi.ModVpnRequest")
	proto.RegisterType((*ModVpnReply)(nil), "nlaapi.ModVpnReply")
	proto.RegisterType((*ModNetlinkReply)(nil), "nlaapi.ModNetlinkReply")
	proto.RegisterType((*GetLinksRequest)(nil), "nlaapi.GetLinksRequest")
	proto.RegisterType((*GetAddrsRequest)(nil), "nlaapi.GetAddrsRequest")
	proto.RegisterType((*GetNeighsRequest)(nil), "nlaapi.GetNeighsRequest")
	proto.RegisterType((*GetRoutesRequest)(nil), "nlaapi.GetRoutesRequest")
	proto.RegisterType((*GetMplssRequest)(nil), "nlaapi.GetMplssRequest")
	proto.RegisterType((*GetNodesRequest)(nil), "nlaapi.GetNodesRequest")
	proto.RegisterType((*GetVpnsRequest)(nil), "nlaapi.GetVpnsRequest")
	proto.RegisterType((*GetEncapInfosRequest)(nil), "nlaapi.GetEncapInfosRequest")
	proto.RegisterType((*GetStatsRequest)(nil), "nlaapi.GetStatsRequest")
	proto.RegisterType((*LinkKey)(nil), "nlaapi.LinkKey")
	proto.RegisterType((*AddrKey)(nil), "nlaapi.AddrKey")
	proto.RegisterType((*NeighKey)(nil), "nlaapi.NeighKey")
	proto.RegisterType((*RouteKey)(nil), "nlaapi.RouteKey")
	proto.RegisterType((*MplsKey)(nil), "nlaapi.MplsKey")
	proto.RegisterType((*NodeKey)(nil), "nlaapi.NodeKey")
	proto.RegisterType((*VpnKey)(nil), "nlaapi.VpnKey")
	proto.RegisterType((*Stat)(nil), "nlaapi.Stat")
	proto.RegisterType((*Node)(nil), "nlaapi.Node")
	proto.RegisterType((*Vpn)(nil), "nlaapi.Vpn")
	proto.RegisterType((*LinkAttrs)(nil), "nlaapi.LinkAttrs")
	proto.RegisterType((*GenericLinkAttrs)(nil), "nlaapi.GenericLinkAttrs")
	proto.RegisterType((*DeviceLinkAttrs)(nil), "nlaapi.DeviceLinkAttrs")
	proto.RegisterType((*BridgeLinkAttrs)(nil), "nlaapi.BridgeLinkAttrs")
	proto.RegisterType((*VlanLinkAttrs)(nil), "nlaapi.VlanLinkAttrs")
	proto.RegisterType((*VxlanLinkAttrs)(nil), "nlaapi.VxlanLinkAttrs")
	proto.RegisterType((*VtiLinkAttrs)(nil), "nlaapi.VtiLinkAttrs")
	proto.RegisterType((*VethLinkAttrs)(nil), "nlaapi.VethLinkAttrs")
	proto.RegisterType((*BondAdInfo)(nil), "nlaapi.BondAdInfo")
	proto.RegisterType((*BondLinkAttrs)(nil), "nlaapi.BondLinkAttrs")
	proto.RegisterType((*Link)(nil), "nlaapi.Link")
	proto.RegisterType((*Addr)(nil), "nlaapi.Addr")
	proto.RegisterType((*Neigh)(nil), "nlaapi.Neigh")
	proto.RegisterType((*NexthopInfo)(nil), "nlaapi.NexthopInfo")
	proto.RegisterType((*MPLSDestination)(nil), "nlaapi.MPLSDestination")
	proto.RegisterType((*Destination)(nil), "nlaapi.Destination")
	proto.RegisterType((*MPLSEncap)(nil), "nlaapi.MPLSEncap")
	proto.RegisterType((*Encap)(nil), "nlaapi.Encap")
	proto.RegisterType((*EncapInfoKey)(nil), "nlaapi.EncapInfoKey")
	proto.RegisterType((*EncapInfo)(nil), "nlaapi.EncapInfo")
	proto.RegisterType((*Route)(nil), "nlaapi.Route")
	proto.RegisterEnum("nlaapi.NlMsgSrc", NlMsgSrc_name, NlMsgSrc_value)
	proto.RegisterEnum("nlaapi.LinkOperState", LinkOperState_name, LinkOperState_value)
	proto.RegisterEnum("nlaapi.BondMode", BondMode_name, BondMode_value)
	proto.RegisterEnum("nlaapi.BondArpValidate", BondArpValidate_name, BondArpValidate_value)
	proto.RegisterEnum("nlaapi.BondArpAllTargets", BondArpAllTargets_name, BondArpAllTargets_value)
	proto.RegisterEnum("nlaapi.BondPrimaryReselect", BondPrimaryReselect_name, BondPrimaryReselect_value)
	proto.RegisterEnum("nlaapi.BondFailOverMac", BondFailOverMac_name, BondFailOverMac_value)
	proto.RegisterEnum("nlaapi.BondXmitHashPolicy", BondXmitHashPolicy_name, BondXmitHashPolicy_value)
	proto.RegisterEnum("nlaapi.BondLacpRate", BondLacpRate_name, BondLacpRate_value)
	proto.RegisterEnum("nlaapi.BondAdSelect", BondAdSelect_name, BondAdSelect_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for NLACoreApi service

type NLACoreApiClient interface {
	SendNetlinkMessage(ctx context.Context, in *NetlinkMessage, opts ...grpc.CallOption) (*NetlinkMessageReply, error)
	MonNetlinkMessage(ctx context.Context, in *Node, opts ...grpc.CallOption) (NLACoreApi_MonNetlinkMessageClient, error)
}

type nLACoreApiClient struct {
	cc *grpc.ClientConn
}

func NewNLACoreApiClient(cc *grpc.ClientConn) NLACoreApiClient {
	return &nLACoreApiClient{cc}
}

func (c *nLACoreApiClient) SendNetlinkMessage(ctx context.Context, in *NetlinkMessage, opts ...grpc.CallOption) (*NetlinkMessageReply, error) {
	out := new(NetlinkMessageReply)
	err := grpc.Invoke(ctx, "/nlaapi.NLACoreApi/SendNetlinkMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nLACoreApiClient) MonNetlinkMessage(ctx context.Context, in *Node, opts ...grpc.CallOption) (NLACoreApi_MonNetlinkMessageClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_NLACoreApi_serviceDesc.Streams[0], c.cc, "/nlaapi.NLACoreApi/MonNetlinkMessage", opts...)
	if err != nil {
		return nil, err
	}
	x := &nLACoreApiMonNetlinkMessageClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NLACoreApi_MonNetlinkMessageClient interface {
	Recv() (*NetlinkMessageUnion, error)
	grpc.ClientStream
}

type nLACoreApiMonNetlinkMessageClient struct {
	grpc.ClientStream
}

func (x *nLACoreApiMonNetlinkMessageClient) Recv() (*NetlinkMessageUnion, error) {
	m := new(NetlinkMessageUnion)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for NLACoreApi service

type NLACoreApiServer interface {
	SendNetlinkMessage(context.Context, *NetlinkMessage) (*NetlinkMessageReply, error)
	MonNetlinkMessage(*Node, NLACoreApi_MonNetlinkMessageServer) error
}

func RegisterNLACoreApiServer(s *grpc.Server, srv NLACoreApiServer) {
	s.RegisterService(&_NLACoreApi_serviceDesc, srv)
}

func _NLACoreApi_SendNetlinkMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetlinkMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NLACoreApiServer).SendNetlinkMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nlaapi.NLACoreApi/SendNetlinkMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NLACoreApiServer).SendNetlinkMessage(ctx, req.(*NetlinkMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _NLACoreApi_MonNetlinkMessage_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Node)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NLACoreApiServer).MonNetlinkMessage(m, &nLACoreApiMonNetlinkMessageServer{stream})
}

type NLACoreApi_MonNetlinkMessageServer interface {
	Send(*NetlinkMessageUnion) error
	grpc.ServerStream
}

type nLACoreApiMonNetlinkMessageServer struct {
	grpc.ServerStream
}

func (x *nLACoreApiMonNetlinkMessageServer) Send(m *NetlinkMessageUnion) error {
	return x.ServerStream.SendMsg(m)
}

var _NLACoreApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "nlaapi.NLACoreApi",
	HandlerType: (*NLACoreApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendNetlinkMessage",
			Handler:    _NLACoreApi_SendNetlinkMessage_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "MonNetlinkMessage",
			Handler:       _NLACoreApi_MonNetlinkMessage_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "nlaapi.proto",
}

// Client API for NLAApi service

type NLAApiClient interface {
	ModVpn(ctx context.Context, in *ModVpnRequest, opts ...grpc.CallOption) (*ModVpnReply, error)
	ModNetlink(ctx context.Context, in *NetlinkMessageUnion, opts ...grpc.CallOption) (*ModNetlinkReply, error)
	MonNetlink(ctx context.Context, in *MonNetlinkRequest, opts ...grpc.CallOption) (NLAApi_MonNetlinkClient, error)
	GetLink(ctx context.Context, in *LinkKey, opts ...grpc.CallOption) (*Link, error)
	GetAddr(ctx context.Context, in *AddrKey, opts ...grpc.CallOption) (*Addr, error)
	GetNeigh(ctx context.Context, in *NeighKey, opts ...grpc.CallOption) (*Neigh, error)
	GetRoute(ctx context.Context, in *RouteKey, opts ...grpc.CallOption) (*Route, error)
	GetMpls(ctx context.Context, in *MplsKey, opts ...grpc.CallOption) (*Route, error)
	GetNode(ctx context.Context, in *NodeKey, opts ...grpc.CallOption) (*Node, error)
	GetVpn(ctx context.Context, in *VpnKey, opts ...grpc.CallOption) (*Vpn, error)
	GetEncapInfo(ctx context.Context, in *EncapInfoKey, opts ...grpc.CallOption) (*EncapInfo, error)
	GetLinks(ctx context.Context, in *GetLinksRequest, opts ...grpc.CallOption) (NLAApi_GetLinksClient, error)
	GetAddrs(ctx context.Context, in *GetAddrsRequest, opts ...grpc.CallOption) (NLAApi_GetAddrsClient, error)
	GetNeighs(ctx context.Context, in *GetNeighsRequest, opts ...grpc.CallOption) (NLAApi_GetNeighsClient, error)
	GetRoutes(ctx context.Context, in *GetRoutesRequest, opts ...grpc.CallOption) (NLAApi_GetRoutesClient, error)
	GetMplss(ctx context.Context, in *GetMplssRequest, opts ...grpc.CallOption) (NLAApi_GetMplssClient, error)
	GetNodes(ctx context.Context, in *GetNodesRequest, opts ...grpc.CallOption) (NLAApi_GetNodesClient, error)
	GetVpns(ctx context.Context, in *GetVpnsRequest, opts ...grpc.CallOption) (NLAApi_GetVpnsClient, error)
	GetEncapInfos(ctx context.Context, in *GetEncapInfosRequest, opts ...grpc.CallOption) (NLAApi_GetEncapInfosClient, error)
	GetStats(ctx context.Context, in *GetStatsRequest, opts ...grpc.CallOption) (NLAApi_GetStatsClient, error)
}

type nLAApiClient struct {
	cc *grpc.ClientConn
}

func NewNLAApiClient(cc *grpc.ClientConn) NLAApiClient {
	return &nLAApiClient{cc}
}

func (c *nLAApiClient) ModVpn(ctx context.Context, in *ModVpnRequest, opts ...grpc.CallOption) (*ModVpnReply, error) {
	out := new(ModVpnReply)
	err := grpc.Invoke(ctx, "/nlaapi.NLAApi/ModVpn", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nLAApiClient) ModNetlink(ctx context.Context, in *NetlinkMessageUnion, opts ...grpc.CallOption) (*ModNetlinkReply, error) {
	out := new(ModNetlinkReply)
	err := grpc.Invoke(ctx, "/nlaapi.NLAApi/ModNetlink", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nLAApiClient) MonNetlink(ctx context.Context, in *MonNetlinkRequest, opts ...grpc.CallOption) (NLAApi_MonNetlinkClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_NLAApi_serviceDesc.Streams[0], c.cc, "/nlaapi.NLAApi/MonNetlink", opts...)
	if err != nil {
		return nil, err
	}
	x := &nLAApiMonNetlinkClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NLAApi_MonNetlinkClient interface {
	Recv() (*NetlinkMessageUnion, error)
	grpc.ClientStream
}

type nLAApiMonNetlinkClient struct {
	grpc.ClientStream
}

func (x *nLAApiMonNetlinkClient) Recv() (*NetlinkMessageUnion, error) {
	m := new(NetlinkMessageUnion)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nLAApiClient) GetLink(ctx context.Context, in *LinkKey, opts ...grpc.CallOption) (*Link, error) {
	out := new(Link)
	err := grpc.Invoke(ctx, "/nlaapi.NLAApi/GetLink", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nLAApiClient) GetAddr(ctx context.Context, in *AddrKey, opts ...grpc.CallOption) (*Addr, error) {
	out := new(Addr)
	err := grpc.Invoke(ctx, "/nlaapi.NLAApi/GetAddr", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nLAApiClient) GetNeigh(ctx context.Context, in *NeighKey, opts ...grpc.CallOption) (*Neigh, error) {
	out := new(Neigh)
	err := grpc.Invoke(ctx, "/nlaapi.NLAApi/GetNeigh", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nLAApiClient) GetRoute(ctx context.Context, in *RouteKey, opts ...grpc.CallOption) (*Route, error) {
	out := new(Route)
	err := grpc.Invoke(ctx, "/nlaapi.NLAApi/GetRoute", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nLAApiClient) GetMpls(ctx context.Context, in *MplsKey, opts ...grpc.CallOption) (*Route, error) {
	out := new(Route)
	err := grpc.Invoke(ctx, "/nlaapi.NLAApi/GetMpls", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nLAApiClient) GetNode(ctx context.Context, in *NodeKey, opts ...grpc.CallOption) (*Node, error) {
	out := new(Node)
	err := grpc.Invoke(ctx, "/nlaapi.NLAApi/GetNode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nLAApiClient) GetVpn(ctx context.Context, in *VpnKey, opts ...grpc.CallOption) (*Vpn, error) {
	out := new(Vpn)
	err := grpc.Invoke(ctx, "/nlaapi.NLAApi/GetVpn", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nLAApiClient) GetEncapInfo(ctx context.Context, in *EncapInfoKey, opts ...grpc.CallOption) (*EncapInfo, error) {
	out := new(EncapInfo)
	err := grpc.Invoke(ctx, "/nlaapi.NLAApi/GetEncapInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nLAApiClient) GetLinks(ctx context.Context, in *GetLinksRequest, opts ...grpc.CallOption) (NLAApi_GetLinksClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_NLAApi_serviceDesc.Streams[1], c.cc, "/nlaapi.NLAApi/GetLinks", opts...)
	if err != nil {
		return nil, err
	}
	x := &nLAApiGetLinksClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NLAApi_GetLinksClient interface {
	Recv() (*Link, error)
	grpc.ClientStream
}

type nLAApiGetLinksClient struct {
	grpc.ClientStream
}

func (x *nLAApiGetLinksClient) Recv() (*Link, error) {
	m := new(Link)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nLAApiClient) GetAddrs(ctx context.Context, in *GetAddrsRequest, opts ...grpc.CallOption) (NLAApi_GetAddrsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_NLAApi_serviceDesc.Streams[2], c.cc, "/nlaapi.NLAApi/GetAddrs", opts...)
	if err != nil {
		return nil, err
	}
	x := &nLAApiGetAddrsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NLAApi_GetAddrsClient interface {
	Recv() (*Addr, error)
	grpc.ClientStream
}

type nLAApiGetAddrsClient struct {
	grpc.ClientStream
}

func (x *nLAApiGetAddrsClient) Recv() (*Addr, error) {
	m := new(Addr)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nLAApiClient) GetNeighs(ctx context.Context, in *GetNeighsRequest, opts ...grpc.CallOption) (NLAApi_GetNeighsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_NLAApi_serviceDesc.Streams[3], c.cc, "/nlaapi.NLAApi/GetNeighs", opts...)
	if err != nil {
		return nil, err
	}
	x := &nLAApiGetNeighsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NLAApi_GetNeighsClient interface {
	Recv() (*Neigh, error)
	grpc.ClientStream
}

type nLAApiGetNeighsClient struct {
	grpc.ClientStream
}

func (x *nLAApiGetNeighsClient) Recv() (*Neigh, error) {
	m := new(Neigh)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nLAApiClient) GetRoutes(ctx context.Context, in *GetRoutesRequest, opts ...grpc.CallOption) (NLAApi_GetRoutesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_NLAApi_serviceDesc.Streams[4], c.cc, "/nlaapi.NLAApi/GetRoutes", opts...)
	if err != nil {
		return nil, err
	}
	x := &nLAApiGetRoutesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NLAApi_GetRoutesClient interface {
	Recv() (*Route, error)
	grpc.ClientStream
}

type nLAApiGetRoutesClient struct {
	grpc.ClientStream
}

func (x *nLAApiGetRoutesClient) Recv() (*Route, error) {
	m := new(Route)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nLAApiClient) GetMplss(ctx context.Context, in *GetMplssRequest, opts ...grpc.CallOption) (NLAApi_GetMplssClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_NLAApi_serviceDesc.Streams[5], c.cc, "/nlaapi.NLAApi/GetMplss", opts...)
	if err != nil {
		return nil, err
	}
	x := &nLAApiGetMplssClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NLAApi_GetMplssClient interface {
	Recv() (*Route, error)
	grpc.ClientStream
}

type nLAApiGetMplssClient struct {
	grpc.ClientStream
}

func (x *nLAApiGetMplssClient) Recv() (*Route, error) {
	m := new(Route)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nLAApiClient) GetNodes(ctx context.Context, in *GetNodesRequest, opts ...grpc.CallOption) (NLAApi_GetNodesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_NLAApi_serviceDesc.Streams[6], c.cc, "/nlaapi.NLAApi/GetNodes", opts...)
	if err != nil {
		return nil, err
	}
	x := &nLAApiGetNodesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NLAApi_GetNodesClient interface {
	Recv() (*Node, error)
	grpc.ClientStream
}

type nLAApiGetNodesClient struct {
	grpc.ClientStream
}

func (x *nLAApiGetNodesClient) Recv() (*Node, error) {
	m := new(Node)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nLAApiClient) GetVpns(ctx context.Context, in *GetVpnsRequest, opts ...grpc.CallOption) (NLAApi_GetVpnsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_NLAApi_serviceDesc.Streams[7], c.cc, "/nlaapi.NLAApi/GetVpns", opts...)
	if err != nil {
		return nil, err
	}
	x := &nLAApiGetVpnsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NLAApi_GetVpnsClient interface {
	Recv() (*Vpn, error)
	grpc.ClientStream
}

type nLAApiGetVpnsClient struct {
	grpc.ClientStream
}

func (x *nLAApiGetVpnsClient) Recv() (*Vpn, error) {
	m := new(Vpn)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nLAApiClient) GetEncapInfos(ctx context.Context, in *GetEncapInfosRequest, opts ...grpc.CallOption) (NLAApi_GetEncapInfosClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_NLAApi_serviceDesc.Streams[8], c.cc, "/nlaapi.NLAApi/GetEncapInfos", opts...)
	if err != nil {
		return nil, err
	}
	x := &nLAApiGetEncapInfosClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NLAApi_GetEncapInfosClient interface {
	Recv() (*EncapInfo, error)
	grpc.ClientStream
}

type nLAApiGetEncapInfosClient struct {
	grpc.ClientStream
}

func (x *nLAApiGetEncapInfosClient) Recv() (*EncapInfo, error) {
	m := new(EncapInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nLAApiClient) GetStats(ctx context.Context, in *GetStatsRequest, opts ...grpc.CallOption) (NLAApi_GetStatsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_NLAApi_serviceDesc.Streams[9], c.cc, "/nlaapi.NLAApi/GetStats", opts...)
	if err != nil {
		return nil, err
	}
	x := &nLAApiGetStatsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NLAApi_GetStatsClient interface {
	Recv() (*Stat, error)
	grpc.ClientStream
}

type nLAApiGetStatsClient struct {
	grpc.ClientStream
}

func (x *nLAApiGetStatsClient) Recv() (*Stat, error) {
	m := new(Stat)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for NLAApi service

type NLAApiServer interface {
	ModVpn(context.Context, *ModVpnRequest) (*ModVpnReply, error)
	ModNetlink(context.Context, *NetlinkMessageUnion) (*ModNetlinkReply, error)
	MonNetlink(*MonNetlinkRequest, NLAApi_MonNetlinkServer) error
	GetLink(context.Context, *LinkKey) (*Link, error)
	GetAddr(context.Context, *AddrKey) (*Addr, error)
	GetNeigh(context.Context, *NeighKey) (*Neigh, error)
	GetRoute(context.Context, *RouteKey) (*Route, error)
	GetMpls(context.Context, *MplsKey) (*Route, error)
	GetNode(context.Context, *NodeKey) (*Node, error)
	GetVpn(context.Context, *VpnKey) (*Vpn, error)
	GetEncapInfo(context.Context, *EncapInfoKey) (*EncapInfo, error)
	GetLinks(*GetLinksRequest, NLAApi_GetLinksServer) error
	GetAddrs(*GetAddrsRequest, NLAApi_GetAddrsServer) error
	GetNeighs(*GetNeighsRequest, NLAApi_GetNeighsServer) error
	GetRoutes(*GetRoutesRequest, NLAApi_GetRoutesServer) error
	GetMplss(*GetMplssRequest, NLAApi_GetMplssServer) error
	GetNodes(*GetNodesRequest, NLAApi_GetNodesServer) error
	GetVpns(*GetVpnsRequest, NLAApi_GetVpnsServer) error
	GetEncapInfos(*GetEncapInfosRequest, NLAApi_GetEncapInfosServer) error
	GetStats(*GetStatsRequest, NLAApi_GetStatsServer) error
}

func RegisterNLAApiServer(s *grpc.Server, srv NLAApiServer) {
	s.RegisterService(&_NLAApi_serviceDesc, srv)
}

func _NLAApi_ModVpn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModVpnRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NLAApiServer).ModVpn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nlaapi.NLAApi/ModVpn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NLAApiServer).ModVpn(ctx, req.(*ModVpnRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NLAApi_ModNetlink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetlinkMessageUnion)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NLAApiServer).ModNetlink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nlaapi.NLAApi/ModNetlink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NLAApiServer).ModNetlink(ctx, req.(*NetlinkMessageUnion))
	}
	return interceptor(ctx, in, info, handler)
}

func _NLAApi_MonNetlink_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MonNetlinkRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NLAApiServer).MonNetlink(m, &nLAApiMonNetlinkServer{stream})
}

type NLAApi_MonNetlinkServer interface {
	Send(*NetlinkMessageUnion) error
	grpc.ServerStream
}

type nLAApiMonNetlinkServer struct {
	grpc.ServerStream
}

func (x *nLAApiMonNetlinkServer) Send(m *NetlinkMessageUnion) error {
	return x.ServerStream.SendMsg(m)
}

func _NLAApi_GetLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LinkKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NLAApiServer).GetLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nlaapi.NLAApi/GetLink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NLAApiServer).GetLink(ctx, req.(*LinkKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _NLAApi_GetAddr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddrKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NLAApiServer).GetAddr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nlaapi.NLAApi/GetAddr",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NLAApiServer).GetAddr(ctx, req.(*AddrKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _NLAApi_GetNeigh_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NeighKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NLAApiServer).GetNeigh(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nlaapi.NLAApi/GetNeigh",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NLAApiServer).GetNeigh(ctx, req.(*NeighKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _NLAApi_GetRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NLAApiServer).GetRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nlaapi.NLAApi/GetRoute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NLAApiServer).GetRoute(ctx, req.(*RouteKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _NLAApi_GetMpls_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MplsKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NLAApiServer).GetMpls(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nlaapi.NLAApi/GetMpls",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NLAApiServer).GetMpls(ctx, req.(*MplsKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _NLAApi_GetNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NLAApiServer).GetNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nlaapi.NLAApi/GetNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NLAApiServer).GetNode(ctx, req.(*NodeKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _NLAApi_GetVpn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VpnKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NLAApiServer).GetVpn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nlaapi.NLAApi/GetVpn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NLAApiServer).GetVpn(ctx, req.(*VpnKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _NLAApi_GetEncapInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncapInfoKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NLAApiServer).GetEncapInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nlaapi.NLAApi/GetEncapInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NLAApiServer).GetEncapInfo(ctx, req.(*EncapInfoKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _NLAApi_GetLinks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetLinksRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NLAApiServer).GetLinks(m, &nLAApiGetLinksServer{stream})
}

type NLAApi_GetLinksServer interface {
	Send(*Link) error
	grpc.ServerStream
}

type nLAApiGetLinksServer struct {
	grpc.ServerStream
}

func (x *nLAApiGetLinksServer) Send(m *Link) error {
	return x.ServerStream.SendMsg(m)
}

func _NLAApi_GetAddrs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetAddrsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NLAApiServer).GetAddrs(m, &nLAApiGetAddrsServer{stream})
}

type NLAApi_GetAddrsServer interface {
	Send(*Addr) error
	grpc.ServerStream
}

type nLAApiGetAddrsServer struct {
	grpc.ServerStream
}

func (x *nLAApiGetAddrsServer) Send(m *Addr) error {
	return x.ServerStream.SendMsg(m)
}

func _NLAApi_GetNeighs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetNeighsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NLAApiServer).GetNeighs(m, &nLAApiGetNeighsServer{stream})
}

type NLAApi_GetNeighsServer interface {
	Send(*Neigh) error
	grpc.ServerStream
}

type nLAApiGetNeighsServer struct {
	grpc.ServerStream
}

func (x *nLAApiGetNeighsServer) Send(m *Neigh) error {
	return x.ServerStream.SendMsg(m)
}

func _NLAApi_GetRoutes_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetRoutesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NLAApiServer).GetRoutes(m, &nLAApiGetRoutesServer{stream})
}

type NLAApi_GetRoutesServer interface {
	Send(*Route) error
	grpc.ServerStream
}

type nLAApiGetRoutesServer struct {
	grpc.ServerStream
}

func (x *nLAApiGetRoutesServer) Send(m *Route) error {
	return x.ServerStream.SendMsg(m)
}

func _NLAApi_GetMplss_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetMplssRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NLAApiServer).GetMplss(m, &nLAApiGetMplssServer{stream})
}

type NLAApi_GetMplssServer interface {
	Send(*Route) error
	grpc.ServerStream
}

type nLAApiGetMplssServer struct {
	grpc.ServerStream
}

func (x *nLAApiGetMplssServer) Send(m *Route) error {
	return x.ServerStream.SendMsg(m)
}

func _NLAApi_GetNodes_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetNodesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NLAApiServer).GetNodes(m, &nLAApiGetNodesServer{stream})
}

type NLAApi_GetNodesServer interface {
	Send(*Node) error
	grpc.ServerStream
}

type nLAApiGetNodesServer struct {
	grpc.ServerStream
}

func (x *nLAApiGetNodesServer) Send(m *Node) error {
	return x.ServerStream.SendMsg(m)
}

func _NLAApi_GetVpns_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetVpnsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NLAApiServer).GetVpns(m, &nLAApiGetVpnsServer{stream})
}

type NLAApi_GetVpnsServer interface {
	Send(*Vpn) error
	grpc.ServerStream
}

type nLAApiGetVpnsServer struct {
	grpc.ServerStream
}

func (x *nLAApiGetVpnsServer) Send(m *Vpn) error {
	return x.ServerStream.SendMsg(m)
}

func _NLAApi_GetEncapInfos_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetEncapInfosRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NLAApiServer).GetEncapInfos(m, &nLAApiGetEncapInfosServer{stream})
}

type NLAApi_GetEncapInfosServer interface {
	Send(*EncapInfo) error
	grpc.ServerStream
}

type nLAApiGetEncapInfosServer struct {
	grpc.ServerStream
}

func (x *nLAApiGetEncapInfosServer) Send(m *EncapInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _NLAApi_GetStats_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetStatsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NLAApiServer).GetStats(m, &nLAApiGetStatsServer{stream})
}

type NLAApi_GetStatsServer interface {
	Send(*Stat) error
	grpc.ServerStream
}

type nLAApiGetStatsServer struct {
	grpc.ServerStream
}

func (x *nLAApiGetStatsServer) Send(m *Stat) error {
	return x.ServerStream.SendMsg(m)
}

var _NLAApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "nlaapi.NLAApi",
	HandlerType: (*NLAApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ModVpn",
			Handler:    _NLAApi_ModVpn_Handler,
		},
		{
			MethodName: "ModNetlink",
			Handler:    _NLAApi_ModNetlink_Handler,
		},
		{
			MethodName: "GetLink",
			Handler:    _NLAApi_GetLink_Handler,
		},
		{
			MethodName: "GetAddr",
			Handler:    _NLAApi_GetAddr_Handler,
		},
		{
			MethodName: "GetNeigh",
			Handler:    _NLAApi_GetNeigh_Handler,
		},
		{
			MethodName: "GetRoute",
			Handler:    _NLAApi_GetRoute_Handler,
		},
		{
			MethodName: "GetMpls",
			Handler:    _NLAApi_GetMpls_Handler,
		},
		{
			MethodName: "GetNode",
			Handler:    _NLAApi_GetNode_Handler,
		},
		{
			MethodName: "GetVpn",
			Handler:    _NLAApi_GetVpn_Handler,
		},
		{
			MethodName: "GetEncapInfo",
			Handler:    _NLAApi_GetEncapInfo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "MonNetlink",
			Handler:       _NLAApi_MonNetlink_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetLinks",
			Handler:       _NLAApi_GetLinks_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetAddrs",
			Handler:       _NLAApi_GetAddrs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetNeighs",
			Handler:       _NLAApi_GetNeighs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetRoutes",
			Handler:       _NLAApi_GetRoutes_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetMplss",
			Handler:       _NLAApi_GetMplss_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetNodes",
			Handler:       _NLAApi_GetNodes_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetVpns",
			Handler:       _NLAApi_GetVpns_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetEncapInfos",
			Handler:       _NLAApi_GetEncapInfos_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetStats",
			Handler:       _NLAApi_GetStats_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "nlaapi.proto",
}

func init() { proto.RegisterFile("nlaapi.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 3464 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x39, 0x5d, 0x6f, 0xe3, 0x48,
	0x72, 0xa2, 0xbe, 0x55, 0x92, 0x6d, 0xba, 0xed, 0x99, 0xd1, 0x78, 0x67, 0xb3, 0xb3, 0xdc, 0x3b,
	0xdc, 0x9e, 0x2f, 0xb7, 0xf0, 0x7a, 0xf6, 0x0e, 0x97, 0x04, 0x79, 0xa0, 0x2d, 0xcf, 0x58, 0x18,
	0x49, 0x76, 0x68, 0x8d, 0x77, 0x27, 0x38, 0x84, 0xe8, 0x11, 0xdb, 0x12, 0x33, 0x14, 0xc9, 0x25,
	0x69, 0xd9, 0x06, 0xf2, 0x78, 0x07, 0xe4, 0x31, 0x4f, 0x79, 0x38, 0x20, 0xff, 0x20, 0x41, 0x9e,
	0xf3, 0x03, 0xf2, 0x98, 0x1f, 0x10, 0xe4, 0x17, 0x04, 0xc8, 0x8f, 0x08, 0xaa, 0xba, 0x49, 0x91,
	0xb2, 0x7c, 0x93, 0xc9, 0x3c, 0xb1, 0xeb, 0xab, 0xbb, 0xba, 0xba, 0xba, 0xba, 0x8a, 0x05, 0x1d,
	0xdf, 0xe3, 0x3c, 0x74, 0xbf, 0x09, 0xa3, 0x20, 0x09, 0x58, 0x5d, 0x42, 0xc6, 0xdf, 0x42, 0x73,
	0xe4, 0x0d, 0xe3, 0xe9, 0xcc, 0x89, 0x98, 0x0e, 0x15, 0x4f, 0xf8, 0x5d, 0xed, 0xb9, 0xf6, 0xf5,
	0x86, 0x85, 0x43, 0xc6, 0xa0, 0x9a, 0xdc, 0x85, 0xa2, 0x5b, 0x26, 0x14, 0x8d, 0xd9, 0x2e, 0xd4,
	0xae, 0x3c, 0x3e, 0x8d, 0xbb, 0x15, 0x42, 0x4a, 0x00, 0x65, 0x63, 0xf1, 0x63, 0xb7, 0x2a, 0x65,
	0x63, 0xf1, 0x23, 0x62, 0x42, 0xd7, 0xe9, 0xd6, 0x24, 0x26, 0x74, 0x1d, 0xe3, 0xf7, 0x1a, 0x6c,
	0x8e, 0x44, 0xe2, 0xb9, 0xfe, 0xfb, 0xa1, 0x88, 0x63, 0x3e, 0x15, 0xec, 0x6b, 0xa8, 0xcf, 0x04,
	0x77, 0x44, 0x44, 0xab, 0xb6, 0x0f, 0xf5, 0x6f, 0x94, 0x96, 0xa9, 0x52, 0x96, 0xa2, 0xa3, 0x2a,
	0x0e, 0x4f, 0x38, 0xa9, 0xd2, 0xb1, 0x68, 0xcc, 0xb6, 0xa1, 0xea, 0xdb, 0xae, 0xa3, 0x34, 0xa9,
	0xf8, 0x7d, 0x87, 0x19, 0x50, 0x89, 0xa3, 0x09, 0xe9, 0xb1, 0xb9, 0x32, 0xdb, 0x45, 0x34, 0xb1,
	0x90, 0x68, 0x3c, 0x82, 0x9d, 0xa2, 0x1a, 0x96, 0x08, 0xbd, 0x3b, 0x63, 0x07, 0xb6, 0x87, 0x81,
	0xaf, 0x28, 0x96, 0xf8, 0xf1, 0x5a, 0xc4, 0x89, 0xf1, 0x3f, 0x9a, 0x32, 0xd0, 0x1b, 0xdf, 0x65,
	0x06, 0x54, 0x91, 0xa6, 0x74, 0xed, 0xa4, 0xb3, 0x0f, 0x5c, 0xff, 0xfd, 0x69, 0xc9, 0x22, 0x1a,
	0xf2, 0x70, 0xc7, 0x89, 0x48, 0xcf, 0x1c, 0x8f, 0xe9, 0x38, 0x11, 0xf2, 0x20, 0x8d, 0xfd, 0x14,
	0x6a, 0xbe, 0x70, 0xa7, 0x33, 0x52, 0xbc, 0x7d, 0xb8, 0x91, 0xa9, 0x89, 0xc8, 0xd3, 0x92, 0x25,
	0xa9, 0xc8, 0x16, 0x05, 0xd7, 0x89, 0xa0, 0xdd, 0xe4, 0xd8, 0x2c, 0x44, 0x22, 0x1b, 0x51, 0x71,
	0x45, 0x3f, 0x70, 0x04, 0x59, 0x3a, 0xb7, 0xe2, 0x28, 0x70, 0x90, 0x89, 0x68, 0xec, 0x0b, 0xa8,
	0x2c, 0x42, 0xbf, 0x5b, 0x27, 0x96, 0x76, 0xca, 0x72, 0x19, 0xfa, 0xa7, 0x25, 0x0b, 0x29, 0x47,
	0x35, 0xa8, 0xcc, 0xe3, 0xa9, 0xf1, 0x07, 0x6d, 0xd5, 0x36, 0x6f, 0x7c, 0x37, 0xf0, 0x3f, 0xe2,
	0x9c, 0x0c, 0x9a, 0x48, 0x6d, 0xbf, 0xc8, 0xf6, 0xc6, 0x77, 0x2d, 0x24, 0xfe, 0x7f, 0xcf, 0xed,
	0x08, 0x36, 0x86, 0x81, 0x73, 0x19, 0xfa, 0xea, 0x70, 0x32, 0xf7, 0xd4, 0x72, 0xee, 0xf9, 0xb9,
	0xdc, 0x69, 0xf9, 0xde, 0x4e, 0x69, 0x9f, 0xc6, 0x06, 0xb4, 0xd3, 0x39, 0xf0, 0xcc, 0xb7, 0x61,
	0x6b, 0x18, 0x38, 0xd9, 0x99, 0x2b, 0xd4, 0x2b, 0x91, 0xe0, 0x99, 0xc6, 0xa9, 0x13, 0x48, 0x14,
	0x1e, 0x61, 0x86, 0x62, 0xa0, 0xbf, 0x12, 0x09, 0x1d, 0xd8, 0x0a, 0x8e, 0x4e, 0x67, 0x45, 0x74,
	0x18, 0x7a, 0xf1, 0x0a, 0x0a, 0x8f, 0x27, 0x43, 0xe9, 0xb0, 0xf9, 0x4a, 0x24, 0x97, 0xa1, 0x9f,
	0x61, 0x1e, 0xc3, 0xee, 0x2b, 0x91, 0x9c, 0xf8, 0x13, 0x1e, 0xf6, 0xfd, 0xab, 0x60, 0x45, 0xf8,
	0x22, 0xe1, 0x49, 0x86, 0x3a, 0x84, 0x06, 0x6a, 0xfb, 0x5a, 0xdc, 0x65, 0x86, 0xd5, 0x96, 0x86,
	0xdd, 0x85, 0x9a, 0xeb, 0x3b, 0xe2, 0x96, 0x2c, 0x52, 0xb3, 0x24, 0x60, 0x1c, 0x40, 0x03, 0xb7,
	0xf3, 0x80, 0x0c, 0xcb, 0xf9, 0x70, 0x4b, 0xfa, 0xac, 0xf1, 0x2d, 0x34, 0x69, 0xb7, 0x1f, 0x27,
	0x42, 0xc6, 0xf8, 0x08, 0x91, 0x5f, 0x41, 0x03, 0x6d, 0xf5, 0x80, 0xc4, 0x13, 0x68, 0x78, 0xb6,
	0xc7, 0xdf, 0x09, 0x4f, 0x45, 0xa4, 0xba, 0x37, 0x40, 0xc8, 0x78, 0x06, 0x0d, 0xb4, 0xe7, 0x7a,
	0x31, 0xe3, 0x2f, 0xa1, 0x7e, 0x19, 0xfa, 0x0f, 0xcc, 0xa9, 0x43, 0xc5, 0x89, 0x13, 0xa5, 0x04,
	0x0e, 0xd9, 0x26, 0x94, 0xa7, 0x37, 0xe4, 0x9b, 0x2d, 0xab, 0x3c, 0xbd, 0x31, 0xf6, 0xa1, 0x8a,
	0xf6, 0x46, 0xce, 0xf7, 0xe2, 0x8e, 0x64, 0x5b, 0x16, 0x0e, 0x11, 0xb3, 0xe0, 0x52, 0x97, 0xaa,
	0x85, 0x43, 0xe3, 0xe7, 0x50, 0x45, 0x45, 0x70, 0x0e, 0x37, 0x24, 0xd6, 0x8e, 0x55, 0x76, 0xc3,
	0x6c, 0xe1, 0xf2, 0x52, 0xab, 0x7f, 0xd0, 0xa0, 0x72, 0x19, 0xfa, 0xf7, 0x58, 0x19, 0x54, 0xe7,
	0x3c, 0x7e, 0x9f, 0x06, 0x3a, 0x1c, 0xe7, 0x54, 0xea, 0xa0, 0x4a, 0x78, 0xa8, 0xd2, 0x0c, 0x32,
	0xde, 0x4a, 0x80, 0x3d, 0x82, 0xfa, 0x22, 0xf4, 0xed, 0xe9, 0x0d, 0x85, 0x82, 0x8e, 0x55, 0x5b,
	0x84, 0xfe, 0xab, 0x9b, 0x6c, 0xed, 0xfa, 0x72, 0xd3, 0x8a, 0xd3, 0x75, 0xba, 0x0d, 0x39, 0xc1,
	0x22, 0x44, 0x95, 0x7e, 0x57, 0x81, 0x16, 0xba, 0x92, 0x99, 0x24, 0x51, 0xbc, 0xf4, 0x1c, 0x2d,
	0xe7, 0x39, 0xb8, 0xe7, 0x79, 0x72, 0xad, 0xbc, 0x09, 0x87, 0xac, 0x0b, 0xcd, 0xe4, 0xd6, 0xfe,
	0xd1, 0xc6, 0xb7, 0xa3, 0x42, 0xe8, 0x7a, 0x72, 0xfb, 0x57, 0x03, 0xf9, 0x7c, 0xf8, 0x7c, 0x2e,
	0xe3, 0x57, 0xcb, 0xa2, 0x31, 0xfb, 0x0a, 0x36, 0x66, 0x3c, 0x72, 0x6e, 0x78, 0x24, 0x6c, 0x3a,
	0x7e, 0xa9, 0x6b, 0x27, 0x45, 0xa2, 0x5b, 0x2e, 0xdf, 0x98, 0x7a, 0xfe, 0x8d, 0xf9, 0x0c, 0x5a,
	0x11, 0xbf, 0xb1, 0x25, 0x45, 0x2a, 0xde, 0x8c, 0xf8, 0xcd, 0x4b, 0x22, 0x7e, 0x09, 0x9d, 0x90,
	0x47, 0xc2, 0x4f, 0x6c, 0xa9, 0x74, 0x93, 0x34, 0x69, 0x4b, 0x5c, 0x9f, 0x54, 0xff, 0x12, 0x3a,
	0x73, 0x1e, 0x27, 0x22, 0x52, 0x2c, 0x2d, 0xc9, 0x22, 0x71, 0x92, 0x65, 0x17, 0x6a, 0xdc, 0x73,
	0x79, 0xdc, 0x05, 0x52, 0x59, 0x02, 0xac, 0x0b, 0x8d, 0x30, 0x0a, 0xe6, 0x6e, 0x3c, 0xe9, 0xb6,
	0x49, 0x26, 0x05, 0xd9, 0xe7, 0x00, 0x02, 0xef, 0xa8, 0x4d, 0x71, 0xa8, 0x43, 0x42, 0x2d, 0xc2,
	0x8c, 0x31, 0x18, 0x7d, 0x07, 0x10, 0x84, 0x22, 0xb2, 0xe3, 0x84, 0x27, 0xa2, 0xbb, 0x41, 0xc1,
	0xed, 0x51, 0xfe, 0xd9, 0x38, 0x0b, 0x45, 0x84, 0xce, 0x25, 0xac, 0x56, 0x90, 0x0e, 0x8d, 0x1e,
	0xc6, 0x11, 0x5f, 0x44, 0xee, 0x64, 0x79, 0x18, 0x07, 0x00, 0x18, 0xa2, 0x6c, 0x8e, 0x90, 0x0a,
	0xc2, 0xdb, 0xf9, 0x99, 0x88, 0xcd, 0x6a, 0x79, 0xe9, 0xd0, 0x38, 0x86, 0xad, 0x9e, 0x58, 0xb8,
	0x13, 0xf1, 0x89, 0x93, 0x1c, 0x45, 0xae, 0x33, 0xfd, 0xa4, 0x49, 0xfe, 0x1a, 0x36, 0x2e, 0x3d,
	0xee, 0x7f, 0xc2, 0x14, 0x78, 0xf3, 0x17, 0x1e, 0xcf, 0xae, 0x50, 0xcd, 0xaa, 0x23, 0xd8, 0x77,
	0x8c, 0xdf, 0x57, 0x61, 0xf3, 0xf2, 0xf6, 0x13, 0x67, 0x7f, 0x0a, 0xcd, 0xc5, 0x6d, 0x61, 0xfa,
	0x06, 0xc1, 0x7d, 0x87, 0xfd, 0x04, 0x36, 0x17, 0x89, 0x08, 0x6d, 0x47, 0x2c, 0x94, 0xd7, 0x48,
	0x17, 0xef, 0x20, 0xb6, 0x27, 0x16, 0xd2, 0x6d, 0x9e, 0x42, 0x33, 0x8e, 0x26, 0xd2, 0x9f, 0xab,
	0xe4, 0xcf, 0x8d, 0x38, 0x9a, 0xa4, 0xae, 0x3c, 0x8d, 0x82, 0xeb, 0x30, 0xbd, 0x93, 0x04, 0xe0,
	0x2d, 0x4a, 0x12, 0x8f, 0xdc, 0xbb, 0x66, 0xe1, 0x90, 0x30, 0x81, 0x74, 0x6b, 0xc4, 0x04, 0x31,
	0xdb, 0x83, 0xa6, 0x27, 0x78, 0xe4, 0xbb, 0xfe, 0x94, 0xbc, 0xb9, 0x69, 0x65, 0x30, 0xce, 0x1a,
	0x46, 0xc1, 0xed, 0x1d, 0xf9, 0x70, 0xd3, 0x92, 0x00, 0xce, 0x11, 0xc5, 0x13, 0xf2, 0xdd, 0xa6,
	0x85, 0x43, 0xf6, 0x18, 0xea, 0xde, 0xe1, 0xdc, 0x8d, 0x63, 0x72, 0xdc, 0xa6, 0xa5, 0x20, 0xc2,
	0xbf, 0x20, 0x7c, 0x47, 0xe1, 0x09, 0x62, 0x7b, 0xd0, 0xba, 0x76, 0x42, 0x7b, 0x62, 0xc7, 0xd7,
	0x73, 0xf2, 0xd7, 0xa6, 0xd5, 0xb8, 0x76, 0xc2, 0xe3, 0x8b, 0xeb, 0x39, 0x06, 0x0d, 0x3f, 0xb0,
	0xf9, 0x54, 0x74, 0x37, 0xe5, 0xa2, 0x7e, 0x60, 0x4e, 0x05, 0x2e, 0x3a, 0x7d, 0x17, 0x76, 0xb7,
	0xe4, 0xa2, 0xd3, 0x77, 0xb4, 0x39, 0xe4, 0xd2, 0xe5, 0x56, 0x30, 0xcd, 0xc3, 0x78, 0xe5, 0xce,
	0xdd, 0xa4, 0xbb, 0x2d, 0x43, 0x09, 0x01, 0x18, 0x1e, 0xc2, 0x20, 0x4a, 0xba, 0x8c, 0x90, 0x34,
	0x46, 0x4b, 0xe2, 0xd7, 0xf6, 0x82, 0x9b, 0xee, 0x8e, 0xba, 0x6b, 0x41, 0x94, 0x0c, 0x82, 0x1b,
	0xbc, 0xfe, 0x44, 0x9a, 0x61, 0xe6, 0xb4, 0x4b, 0x34, 0xe2, 0x3d, 0x75, 0xa7, 0x33, 0xe3, 0x9f,
	0x35, 0xe8, 0x5c, 0x26, 0xee, 0xa7, 0x78, 0xc1, 0x0e, 0xd4, 0x5c, 0x1b, 0x23, 0xbc, 0xca, 0x76,
	0x5d, 0x7c, 0x31, 0x76, 0xa0, 0x16, 0x10, 0x52, 0xe6, 0x2a, 0xd5, 0x00, 0x91, 0x4c, 0xe5, 0x81,
	0x32, 0xfa, 0xca, 0xbc, 0x0f, 0xb7, 0x18, 0x4c, 0xb8, 0x97, 0x9e, 0x33, 0x01, 0x68, 0xe7, 0x48,
	0xcc, 0x83, 0x44, 0xd0, 0x51, 0x77, 0x2c, 0x05, 0x19, 0x7f, 0x03, 0x1b, 0x97, 0x22, 0x99, 0x7d,
	0x8a, 0xba, 0x68, 0x0e, 0x21, 0x22, 0x9b, 0x22, 0xac, 0x7c, 0xbe, 0x9a, 0x88, 0x18, 0xf1, 0xb9,
	0x30, 0xfe, 0x45, 0x03, 0x38, 0x0a, 0x7c, 0xc7, 0x74, 0x30, 0x7b, 0xc0, 0xa0, 0xcb, 0xa7, 0xd3,
	0x48, 0x4c, 0x79, 0x12, 0x44, 0xe9, 0x03, 0x58, 0xb3, 0x3a, 0x4b, 0x64, 0xdf, 0xc1, 0x09, 0xfd,
	0xeb, 0xb9, 0x8d, 0x26, 0x8d, 0xd5, 0x35, 0x68, 0xfa, 0xd7, 0xf3, 0x73, 0x84, 0x91, 0xc8, 0x27,
	0x28, 0x9c, 0xda, 0xa2, 0x66, 0x35, 0x09, 0x81, 0xf6, 0xf8, 0x02, 0x30, 0xce, 0x26, 0xbe, 0x90,
	0xe4, 0x2a, 0x91, 0x41, 0xa1, 0x56, 0x18, 0xe6, 0x7c, 0xa2, 0x4c, 0x94, 0x32, 0x0c, 0xf9, 0xc4,
	0xf8, 0x43, 0x13, 0x36, 0x50, 0xdf, 0x4f, 0x31, 0xc8, 0x4f, 0xa0, 0x3a, 0xc7, 0x3c, 0xb8, 0x5c,
	0xcc, 0x21, 0x71, 0xda, 0x61, 0xe0, 0x08, 0x8b, 0xa8, 0xf8, 0x08, 0xf0, 0x49, 0xe2, 0x2e, 0x84,
	0x1d, 0x7b, 0x7c, 0x21, 0xd4, 0x5e, 0xda, 0x12, 0x77, 0x81, 0x28, 0x3c, 0xb4, 0xb9, 0xeb, 0xce,
	0x03, 0x5f, 0xed, 0x44, 0x41, 0xe8, 0x9b, 0xd7, 0x18, 0x09, 0x3c, 0x7e, 0x47, 0x5b, 0xa8, 0x59,
	0x8d, 0xeb, 0xb0, 0x87, 0x20, 0xbe, 0x03, 0x4e, 0x70, 0xe3, 0x2b, 0xa2, 0xbc, 0xd6, 0x2d, 0xc4,
	0x48, 0xf2, 0x17, 0xd0, 0xbe, 0x8e, 0x85, 0x3d, 0xe1, 0x51, 0xe4, 0x8a, 0x48, 0x5d, 0x72, 0xb8,
	0x8e, 0xc5, 0xb1, 0xc4, 0x90, 0x56, 0x51, 0x68, 0xbb, 0x7e, 0x22, 0x22, 0x4c, 0x29, 0xd4, 0xeb,
	0xc5, 0xa3, 0xb0, 0xaf, 0x50, 0x18, 0x89, 0x88, 0x25, 0xb4, 0x13, 0x1e, 0x4d, 0x45, 0x12, 0x77,
	0x5b, 0xcf, 0x2b, 0xf8, 0x72, 0x22, 0x53, 0x38, 0x96, 0x38, 0xf6, 0xe7, 0x72, 0xa2, 0x05, 0xf7,
	0x5c, 0x07, 0xdf, 0x1c, 0x20, 0x63, 0x3c, 0xc9, 0x1b, 0xc3, 0x8c, 0xc2, 0x4b, 0x45, 0xa6, 0x15,
	0x52, 0x80, 0x99, 0xb0, 0x85, 0xb2, 0xdc, 0xf3, 0xb2, 0x25, 0xda, 0x24, 0xfe, 0x74, 0x45, 0xdc,
	0xf4, 0x3c, 0xb5, 0x9e, 0xb5, 0xc1, 0xf3, 0xa0, 0x7c, 0x29, 0xdd, 0x39, 0x8f, 0xee, 0x28, 0xb0,
	0xd0, 0x4b, 0x49, 0x20, 0x7b, 0x09, 0xba, 0x1a, 0xda, 0x91, 0x88, 0x85, 0x27, 0x26, 0x89, 0x7a,
	0x10, 0x3f, 0xcb, 0xcf, 0x7e, 0x2e, 0x79, 0x2c, 0xc5, 0x62, 0x6d, 0x85, 0x45, 0x04, 0xfb, 0x0b,
	0xd8, 0xb8, 0xe2, 0xae, 0x67, 0x07, 0x0b, 0xe5, 0x4c, 0x9b, 0xf7, 0x77, 0xf8, 0x92, 0xbb, 0xde,
	0xd9, 0x82, 0x3c, 0xcb, 0x6a, 0x5f, 0x2d, 0x01, 0xd6, 0x03, 0xfd, 0x76, 0xee, 0x26, 0xf6, 0x8c,
	0xc7, 0x33, 0x3b, 0x0c, 0x3c, 0x77, 0x72, 0x47, 0x81, 0x6b, 0xf3, 0x70, 0x2f, 0x2f, 0xff, 0xc3,
	0xdc, 0x4d, 0x4e, 0x79, 0x3c, 0x3b, 0x27, 0x0e, 0x6b, 0xf3, 0xb6, 0x00, 0xe3, 0x69, 0xe2, 0x16,
	0x7c, 0xc7, 0x76, 0xa7, 0xf3, 0x50, 0xc5, 0x39, 0x90, 0xa8, 0xfe, 0x74, 0x1e, 0xe2, 0x51, 0xd1,
	0x4d, 0xa2, 0xeb, 0x19, 0x24, 0xee, 0x95, 0x8a, 0x7b, 0x1d, 0xbc, 0x4e, 0x78, 0x45, 0x11, 0xc7,
	0xf6, 0x61, 0x1b, 0x4d, 0x4d, 0x6e, 0x18, 0xdb, 0xd2, 0x01, 0x55, 0x2c, 0xdc, 0xe2, 0x9e, 0x47,
	0xbe, 0x18, 0x9b, 0x84, 0xc6, 0xeb, 0x37, 0x77, 0x7d, 0x1b, 0x9d, 0x3d, 0x56, 0x71, 0xb1, 0x39,
	0x77, 0xe9, 0xd1, 0x8b, 0x51, 0x1f, 0x2f, 0xe7, 0x3b, 0x32, 0x34, 0x82, 0xb7, 0x74, 0x9d, 0x7d,
	0xd8, 0x0e, 0xf9, 0xe4, 0xbd, 0x88, 0x62, 0x9b, 0xb2, 0x11, 0x72, 0xfc, 0x47, 0x72, 0x25, 0x45,
	0x38, 0x17, 0x91, 0x74, 0xfe, 0x6f, 0xa1, 0xe5, 0xf1, 0x49, 0x68, 0x47, 0xe8, 0x3d, 0x8f, 0xc9,
	0x36, 0xbb, 0x79, 0xdb, 0x0c, 0xf8, 0x24, 0xb4, 0xd0, 0x75, 0x9a, 0x9e, 0x1a, 0xa1, 0x08, 0x77,
	0x6c, 0x75, 0xa6, 0x4f, 0xee, 0x8b, 0x98, 0xce, 0x85, 0x3c, 0xcc, 0x26, 0x57, 0x23, 0xf6, 0x0b,
	0x68, 0x70, 0xc7, 0x76, 0xfd, 0xab, 0xa0, 0xdb, 0xa5, 0xab, 0xcd, 0x8a, 0x02, 0x18, 0xb5, 0xac,
	0x3a, 0xa7, 0xaf, 0xf1, 0x1f, 0x15, 0xa8, 0xe2, 0x4e, 0x0b, 0xf5, 0x5e, 0x4b, 0xd5, 0x7b, 0xdf,
	0x42, 0xdd, 0xa1, 0x34, 0x47, 0x95, 0x7c, 0x99, 0x23, 0xac, 0x24, 0x3f, 0xa7, 0x25, 0x4b, 0x31,
	0xa2, 0xc8, 0x3b, 0x4a, 0x6a, 0x54, 0xfd, 0xbd, 0xf4, 0x9d, 0x62, 0xaa, 0x83, 0x22, 0x92, 0x91,
	0xfd, 0x02, 0xaa, 0x98, 0x70, 0xa8, 0x4a, 0x3c, 0x4b, 0xe1, 0x0a, 0x69, 0x0d, 0x16, 0xdb, 0xc8,
	0xc4, 0xbe, 0x81, 0x1a, 0xa5, 0x0f, 0xaa, 0x22, 0x7f, 0x9c, 0x71, 0xdf, 0xae, 0xb0, 0x4b, 0x36,
	0xf6, 0x35, 0x54, 0x16, 0x89, 0xab, 0x8a, 0xf3, 0xcc, 0x72, 0xf9, 0xd7, 0x8c, 0xaa, 0xf4, 0xc4,
	0x25, 0x35, 0x44, 0x32, 0xa3, 0x00, 0x92, 0x57, 0x23, 0xff, 0x94, 0x90, 0x1a, 0x22, 0x99, 0x21,
	0xf3, 0xbb, 0xc0, 0x77, 0x28, 0x96, 0xe4, 0x98, 0x0b, 0x61, 0x16, 0x99, 0x91, 0x89, 0x7d, 0x07,
	0x8d, 0xa9, 0xcc, 0x39, 0x29, 0xa5, 0x68, 0x1f, 0x76, 0x53, 0xfe, 0xd5, 0x54, 0xf4, 0xb4, 0x64,
	0xa5, 0xac, 0x59, 0x69, 0x01, 0xcb, 0xd2, 0x62, 0x07, 0x6a, 0x1e, 0xe1, 0xda, 0xea, 0x71, 0xf4,
	0xfb, 0xce, 0x51, 0x27, 0x1f, 0xcc, 0x8d, 0x7f, 0x2c, 0x43, 0x95, 0x72, 0xa3, 0xd5, 0xd2, 0xe7,
	0x09, 0x34, 0xdc, 0xd0, 0xce, 0x55, 0x3f, 0x75, 0x37, 0x1c, 0x62, 0xfd, 0x93, 0xd5, 0x3b, 0xb2,
	0x2a, 0x53, 0xf5, 0x4e, 0x56, 0x25, 0xc8, 0x30, 0xad, 0xaa, 0x84, 0x5d, 0xa8, 0xc5, 0x93, 0x20,
	0x14, 0x2a, 0x44, 0x4b, 0x80, 0x72, 0x0d, 0x21, 0x22, 0xf5, 0x0c, 0xd3, 0x38, 0x7b, 0x41, 0x69,
	0xc1, 0x06, 0x11, 0xe8, 0x05, 0xa5, 0x25, 0x9f, 0x41, 0xeb, 0x5d, 0x14, 0x70, 0x67, 0xc2, 0xe3,
	0x84, 0x4c, 0xd8, 0xb1, 0x96, 0x88, 0x65, 0x6d, 0xd4, 0xca, 0xd7, 0x46, 0x8f, 0xa1, 0x7e, 0xc5,
	0xe7, 0xae, 0x77, 0x47, 0x06, 0xa9, 0x59, 0x0a, 0xca, 0xcc, 0xd4, 0x2e, 0x98, 0x09, 0x2f, 0x80,
	0x43, 0x61, 0x72, 0x03, 0xab, 0xdf, 0xbe, 0x63, 0xfc, 0x97, 0x06, 0x35, 0x2a, 0xb2, 0xf1, 0x3d,
	0x21, 0x83, 0xe5, 0x0b, 0x30, 0x7a, 0xea, 0xfa, 0x2b, 0x0b, 0x95, 0x0b, 0x0b, 0xe1, 0xde, 0xa9,
	0xd4, 0xa8, 0xa8, 0xbd, 0x23, 0x90, 0x5d, 0x1b, 0x69, 0xa6, 0x95, 0xbf, 0x78, 0xb5, 0xbc, 0xed,
	0xe4, 0x81, 0xd4, 0xb3, 0x03, 0xb9, 0x57, 0xac, 0x35, 0xd6, 0x14, 0x6b, 0xe9, 0xee, 0x9a, 0x85,
	0xdd, 0xf9, 0x02, 0x71, 0x2d, 0xb9, 0x3b, 0x5f, 0xf4, 0x1d, 0xe3, 0xdf, 0x34, 0x68, 0x8f, 0xc4,
	0x6d, 0x32, 0x0b, 0xe8, 0x97, 0xc6, 0x87, 0xf6, 0xc8, 0xa0, 0x3a, 0x0b, 0xc2, 0x34, 0x13, 0xa1,
	0xf1, 0xba, 0x3a, 0x78, 0x8d, 0x07, 0xfc, 0x29, 0x34, 0x7c, 0x71, 0x63, 0x63, 0x59, 0x2f, 0x6f,
	0xe0, 0xce, 0x32, 0x26, 0xc4, 0x89, 0xeb, 0xf3, 0xc4, 0x0d, 0x7c, 0xab, 0xee, 0x8b, 0x9b, 0x5e,
	0x9c, 0xb0, 0xaf, 0xa0, 0x46, 0x05, 0x9b, 0xba, 0x7f, 0xd9, 0x5f, 0x36, 0xfa, 0xf7, 0x62, 0x49,
	0x9a, 0xf1, 0x73, 0xd8, 0x1a, 0x9e, 0x0f, 0x2e, 0x72, 0xf2, 0x94, 0x42, 0xa3, 0x1b, 0x62, 0x72,
	0x52, 0xa1, 0x7f, 0x11, 0x04, 0x19, 0xbf, 0x85, 0xf6, 0x0a, 0x9b, 0x3a, 0x2a, 0xad, 0x70, 0x54,
	0xbf, 0x84, 0xea, 0x3c, 0xf4, 0xe2, 0xd5, 0xa8, 0xb5, 0xb2, 0x0a, 0xde, 0x4f, 0x64, 0x3b, 0xaa,
	0x43, 0xd5, 0x11, 0x71, 0x62, 0x7c, 0x05, 0x2d, 0x64, 0x21, 0xe5, 0x1e, 0x54, 0x61, 0x08, 0x35,
	0xc9, 0xb0, 0xee, 0x07, 0xd9, 0xcf, 0x0a, 0x0b, 0x6f, 0xe7, 0x17, 0x26, 0xa1, 0x6c, 0xc9, 0x86,
	0x32, 0x8c, 0x71, 0x08, 0x9d, 0xec, 0x47, 0xd4, 0x6b, 0xf9, 0xdb, 0x03, 0x6d, 0xab, 0x2d, 0x7f,
	0x99, 0xe8, 0x50, 0x59, 0x44, 0x57, 0xe9, 0xdf, 0x8d, 0x45, 0x74, 0x65, 0x5c, 0x42, 0x2b, 0x93,
	0xf9, 0x3f, 0xfd, 0xe2, 0x50, 0x53, 0x54, 0xb2, 0x29, 0xd0, 0x89, 0x04, 0x39, 0x96, 0x4a, 0xb3,
	0x05, 0xd6, 0x7b, 0xff, 0x5a, 0x85, 0x1a, 0xfd, 0x54, 0xfa, 0x90, 0xfb, 0x3c, 0x87, 0x8e, 0x6b,
	0xe7, 0x18, 0xa4, 0x1b, 0x01, 0xc5, 0xd4, 0xac, 0xd6, 0x97, 0x81, 0xa2, 0x92, 0x0f, 0x14, 0x6a,
	0x73, 0xb2, 0x8a, 0xa3, 0xcd, 0x3d, 0x85, 0xa6, 0x13, 0x27, 0x32, 0x4a, 0xc8, 0xcc, 0xb5, 0xe1,
	0xc4, 0xc9, 0x50, 0x29, 0x1d, 0x47, 0x13, 0x75, 0x61, 0x70, 0xa8, 0x3c, 0xb4, 0x91, 0x79, 0xe8,
	0x21, 0xc0, 0xfc, 0xda, 0x4b, 0x5c, 0x3b, 0xe4, 0xc9, 0xac, 0xdb, 0x7c, 0x5e, 0xc9, 0xbb, 0x63,
	0xee, 0x36, 0x58, 0x2d, 0x62, 0x3b, 0xe7, 0xc9, 0x0c, 0x0b, 0x3f, 0xfa, 0x49, 0x3f, 0x09, 0x3c,
	0x15, 0x5f, 0x32, 0x58, 0xd2, 0xdc, 0x20, 0x72, 0x93, 0x34, 0xc8, 0x64, 0x30, 0x6e, 0x28, 0xe1,
	0xef, 0x3c, 0xa1, 0x7e, 0x52, 0x48, 0x20, 0xf3, 0x81, 0x4e, 0xee, 0xf6, 0xab, 0x62, 0x73, 0x63,
	0x59, 0x6c, 0x66, 0x37, 0x69, 0x33, 0x7f, 0x93, 0x9e, 0x42, 0x13, 0x5d, 0x81, 0xae, 0xd2, 0x96,
	0xcc, 0xe7, 0x10, 0xc6, 0x6b, 0x93, 0xbb, 0x64, 0xfa, 0x47, 0x5c, 0xb2, 0xed, 0x87, 0x2f, 0x59,
	0x16, 0x48, 0x58, 0x21, 0x90, 0x44, 0x09, 0xe2, 0x76, 0xa4, 0x0f, 0x44, 0xc9, 0xf2, 0xef, 0xd5,
	0xf4, 0x86, 0x52, 0x9d, 0xec, 0x3f, 0xd7, 0x23, 0xa8, 0x93, 0xbf, 0xc4, 0xdd, 0x47, 0x74, 0x1b,
	0x6a, 0xe8, 0x30, 0xf1, 0xfe, 0x4f, 0xd5, 0x0f, 0xfc, 0x8b, 0x68, 0xc2, 0x1a, 0x50, 0x19, 0x9d,
	0x9d, 0xeb, 0x25, 0x1c, 0xbc, 0x1e, 0x0d, 0x74, 0x0d, 0x07, 0xe6, 0x79, 0x5f, 0x2f, 0xef, 0xff,
	0xbd, 0x06, 0x1b, 0x85, 0x3f, 0x32, 0x6c, 0x0b, 0xda, 0x08, 0xbc, 0xf1, 0xdf, 0xfb, 0xc1, 0x8d,
	0xaf, 0x97, 0x18, 0x83, 0x4d, 0x44, 0x8c, 0x82, 0xe4, 0x9c, 0x92, 0xbd, 0x44, 0xd7, 0x58, 0x07,
	0x9a, 0x88, 0xeb, 0x21, 0x47, 0x99, 0x3d, 0x06, 0x86, 0xd0, 0x20, 0xb8, 0x11, 0xd1, 0x80, 0xdf,
	0x29, 0x7c, 0x25, 0x9d, 0x6a, 0x4c, 0x96, 0x99, 0xea, 0xd5, 0x14, 0xd1, 0x0b, 0xa2, 0x39, 0xf7,
	0x13, 0xbd, 0xc6, 0x00, 0xea, 0xb4, 0x58, 0xa8, 0xd7, 0xf7, 0xff, 0x53, 0x83, 0x66, 0x5a, 0xb5,
	0xb0, 0x2e, 0xec, 0x1e, 0x9d, 0x8d, 0x7a, 0xf6, 0xf0, 0xac, 0x77, 0x62, 0x1f, 0x99, 0x03, 0x73,
	0x74, 0x7c, 0x62, 0x5b, 0x96, 0x5e, 0x62, 0x9f, 0xc1, 0x93, 0x25, 0xc5, 0x3c, 0x1e, 0xf7, 0x2f,
	0x91, 0xe1, 0xf8, 0xf5, 0x9b, 0x73, 0x5d, 0x63, 0x4f, 0xe1, 0xd1, 0x7d, 0xb1, 0x1f, 0xce, 0x2c,
	0xbd, 0xcc, 0x9e, 0xc0, 0x4e, 0x8e, 0x64, 0x9d, 0x99, 0xbd, 0x63, 0xf3, 0x62, 0xac, 0x57, 0xd8,
	0x23, 0xd8, 0x5e, 0x12, 0x7e, 0x73, 0x70, 0x68, 0xbf, 0x30, 0x7b, 0x7a, 0x75, 0xfd, 0x54, 0xe3,
	0xc1, 0x91, 0x5e, 0x5b, 0x4f, 0x32, 0x07, 0x47, 0x7a, 0xbd, 0x38, 0xd9, 0x9b, 0xd1, 0xeb, 0xd1,
	0xd9, 0xf7, 0x23, 0xbd, 0xb1, 0xff, 0x3b, 0x0d, 0xb6, 0x56, 0x8a, 0x10, 0xb6, 0x07, 0x8f, 0x89,
	0xd5, 0xb4, 0xce, 0xed, 0x4b, 0x73, 0xd0, 0xef, 0x99, 0xe3, 0x13, 0x7b, 0x74, 0x36, 0x3a, 0xd1,
	0x4b, 0xec, 0x19, 0x74, 0xef, 0xd3, 0xe4, 0x66, 0x75, 0x6d, 0x3d, 0x55, 0xd9, 0xa0, 0x9c, 0x69,
	0x57, 0x94, 0x1d, 0x0c, 0xf4, 0xca, 0xfe, 0x19, 0x6c, 0xdf, 0xab, 0x65, 0x0a, 0xb3, 0x99, 0x83,
	0x81, 0x3d, 0x36, 0xad, 0x57, 0x27, 0xe3, 0x0b, 0xdb, 0x1c, 0xbd, 0x5d, 0xd1, 0xa4, 0x40, 0x1d,
	0x0c, 0x74, 0x6d, 0xff, 0xef, 0x60, 0x67, 0x4d, 0xf9, 0xc2, 0x9e, 0xc3, 0x33, 0x12, 0x3a, 0xb7,
	0xfa, 0x43, 0xd3, 0x7a, 0x6b, 0x5b, 0x27, 0x17, 0x27, 0x83, 0x93, 0xe3, 0xb1, 0x6d, 0x0e, 0xbe,
	0x37, 0xdf, 0x5e, 0xe8, 0xa5, 0x87, 0x39, 0x8e, 0x4e, 0xc6, 0xe3, 0x13, 0x4b, 0xd7, 0xd8, 0x97,
	0xf0, 0xf9, 0x7a, 0x8e, 0x97, 0x66, 0x7f, 0xf0, 0xc6, 0x3a, 0xd1, 0xcb, 0xfb, 0x9e, 0x34, 0x6a,
	0xae, 0xee, 0xc9, 0xbc, 0x03, 0x99, 0xec, 0xb3, 0xcb, 0x13, 0xcb, 0x1e, 0x9a, 0xc7, 0xa9, 0x55,
	0x3f, 0x87, 0xa7, 0x6b, 0x88, 0x99, 0x59, 0xd7, 0x93, 0x5f, 0x9e, 0x0d, 0x06, 0x67, 0xdf, 0xeb,
	0xe5, 0xfd, 0xff, 0xd6, 0x80, 0xdd, 0x2f, 0x93, 0xb2, 0x9d, 0xfc, 0x30, 0xec, 0x8f, 0xed, 0x53,
	0xf3, 0xe2, 0xd4, 0x3e, 0x3f, 0x1b, 0xf4, 0x8f, 0xdf, 0xda, 0x03, 0xf3, 0xed, 0x89, 0x75, 0xa8,
	0x97, 0x98, 0x01, 0x7f, 0xf2, 0x47, 0x38, 0x5e, 0xd8, 0xdf, 0xe9, 0xda, 0x07, 0x78, 0x0e, 0xed,
	0x17, 0x7a, 0xf9, 0x61, 0x9e, 0x93, 0xd1, 0xb1, 0x79, 0x8e, 0x3c, 0x95, 0x0f, 0xf0, 0xe0, 0x5a,
	0xd5, 0xcc, 0xb2, 0xf7, 0x78, 0x52, 0x7f, 0xad, 0xed, 0xff, 0x16, 0x3a, 0xf9, 0xaa, 0x27, 0xbb,
	0x3c, 0x03, 0xf3, 0xf8, 0xdc, 0xb6, 0xd0, 0xa1, 0x2e, 0xd0, 0x28, 0xa5, 0x35, 0x84, 0x97, 0x78,
	0xab, 0xb4, 0xcc, 0xbb, 0x97, 0x84, 0x74, 0xf6, 0xf2, 0x3e, 0x97, 0xb3, 0xa7, 0x05, 0xd2, 0xd2,
	0x63, 0x7b, 0xb6, 0x3a, 0xe3, 0x8b, 0xb1, 0x79, 0x34, 0x28, 0x5c, 0x84, 0x8c, 0x74, 0x64, 0x8e,
	0x7a, 0xdf, 0xf7, 0x7b, 0xe3, 0x53, 0x5d, 0xcb, 0xa2, 0xc4, 0x92, 0x7a, 0x7c, 0xf6, 0x66, 0x34,
	0xd6, 0xcb, 0x87, 0xff, 0xa4, 0x01, 0x8c, 0x06, 0xe6, 0x71, 0x10, 0x09, 0x33, 0x74, 0xd9, 0x6b,
	0x60, 0x17, 0xc2, 0x77, 0x56, 0xda, 0xb0, 0x8f, 0x97, 0x2f, 0x52, 0x1e, 0xbf, 0xf7, 0xd9, 0x7a,
	0xbc, 0x6c, 0x94, 0x95, 0xd8, 0x51, 0xbe, 0x63, 0x9a, 0xce, 0x55, 0x68, 0x40, 0x3e, 0x34, 0x03,
	0x75, 0x15, 0x8d, 0xd2, 0x81, 0x76, 0xf8, 0xef, 0x4d, 0xa8, 0x8f, 0x06, 0x26, 0xea, 0xf6, 0x6b,
	0xa8, 0xcb, 0xde, 0x1c, 0xcb, 0x8a, 0x95, 0x42, 0xbf, 0x6f, 0x6f, 0x67, 0x15, 0x2d, 0xd5, 0xe8,
	0x01, 0x2c, 0x9b, 0x78, 0xec, 0x8f, 0xad, 0xb8, 0xf7, 0x24, 0x37, 0x43, 0xa1, 0xeb, 0x57, 0x62,
	0xa7, 0x38, 0x4b, 0xba, 0x19, 0xf6, 0x74, 0xc9, 0xb8, 0xd2, 0x12, 0xfe, 0xe0, 0x96, 0xd8, 0x3e,
	0x34, 0x54, 0x07, 0x91, 0x6d, 0xe5, 0xff, 0x58, 0xbd, 0x16, 0x77, 0x7b, 0x85, 0xa6, 0xb1, 0x51,
	0x52, 0xbc, 0x94, 0x47, 0x6f, 0xe5, 0x7b, 0xc5, 0x05, 0x5e, 0x44, 0x18, 0x25, 0xf6, 0x4b, 0x68,
	0xa6, 0x3d, 0x47, 0xa6, 0x17, 0x7a, 0xc6, 0xc8, 0x5d, 0xec, 0x22, 0x67, 0xec, 0x32, 0x59, 0xd2,
	0x0b, 0xbd, 0xe3, 0x02, 0x3b, 0x61, 0x8c, 0x12, 0x96, 0xe4, 0xaa, 0x53, 0xb9, 0xd4, 0x44, 0xf5,
	0xe2, 0xee, 0x33, 0x4b, 0xb5, 0xa9, 0xd5, 0xb5, 0x95, 0x3f, 0xef, 0x82, 0xda, 0x88, 0x30, 0x4a,
	0xec, 0x67, 0x50, 0x97, 0xcd, 0x4d, 0xb6, 0x99, 0x6b, 0xc7, 0x22, 0x67, 0xbe, 0x3d, 0x6b, 0x94,
	0xd8, 0x9f, 0x41, 0x27, 0xdf, 0xf3, 0x64, 0xbb, 0x85, 0x2c, 0x41, 0x65, 0x9f, 0x7b, 0xdb, 0xf7,
	0xb0, 0x46, 0x89, 0xfd, 0x8a, 0xf6, 0x2a, 0x7f, 0x87, 0x3c, 0x59, 0x56, 0xae, 0x85, 0x36, 0xee,
	0xaa, 0xed, 0x0f, 0x34, 0x25, 0x46, 0x8d, 0xdd, 0x82, 0x58, 0xbe, 0xd5, 0xbb, 0x7a, 0x0c, 0x07,
	0x1a, 0xfb, 0x0d, 0xb4, 0xb2, 0xe6, 0x2f, 0xcb, 0x15, 0xca, 0xc5, 0x7e, 0xf0, 0xbd, 0x13, 0xc9,
	0x24, 0x65, 0x8b, 0xb8, 0x20, 0x59, 0xe8, 0x1a, 0xdf, 0xb3, 0xf7, 0x81, 0xc6, 0x7e, 0x4d, 0xaa,
	0x52, 0x23, 0xb9, 0xa0, 0x6a, 0xbe, 0xb5, 0xbc, 0x4e, 0x4e, 0x6e, 0x91, 0xba, 0xcd, 0x05, 0xb9,
	0x7c, 0xff, 0x79, 0xf5, 0xc8, 0x0e, 0x34, 0x76, 0x48, 0x07, 0x7c, 0x19, 0xfa, 0xf1, 0x32, 0x38,
	0x14, 0x5b, 0xd4, 0x2b, 0xa7, 0x77, 0xa0, 0xb1, 0x1e, 0x6c, 0x14, 0x7a, 0xd6, 0xec, 0x59, 0x4e,
	0xf2, 0x5e, 0x2b, 0x7b, 0xed, 0x41, 0x66, 0x0a, 0x53, 0x87, 0xbb, 0xa0, 0x70, 0xbe, 0xe7, 0xbd,
	0x54, 0x18, 0xb1, 0x28, 0xf6, 0xae, 0x4e, 0x29, 0xf2, 0x8b, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff,
	0xb3, 0x93, 0x5a, 0x39, 0xe7, 0x22, 0x00, 0x00,
}
