// Code generated by protoc-gen-go. DO NOT EDIT.
// source: fibcapi.proto

/*
Package fibcapi is a generated protocol buffer package.

It is generated from these files:
	fibcapi.proto

It has these top-level messages:
	Hello
	DpStatus
	PortStatus
	PortConfig
	FlowMod
	GroupMod
	VLANFlow
	TerminationMacFlow
	MPLSFlow
	UnicastRoutingFlow
	BridgingFlow
	PolicyACLFlow
	L2InterfaceGroup
	L3UnicastGroup
	MPLSInterfaceGroup
	MPLSLabelGroup
*/
package fibcapi

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// FF Message types
type FFM int32

const (
	FFM_UNSPEC      FFM = 0
	FFM_HELLO       FFM = 1
	FFM_PORT_STATUS FFM = 2
	FFM_PORT_CONFIG FFM = 3
	FFM_FLOW_MOD    FFM = 4
	FFM_GROUP_MOD   FFM = 5
	FFM_DP_STATUS   FFM = 6
)

var FFM_name = map[int32]string{
	0: "UNSPEC",
	1: "HELLO",
	2: "PORT_STATUS",
	3: "PORT_CONFIG",
	4: "FLOW_MOD",
	5: "GROUP_MOD",
	6: "DP_STATUS",
}
var FFM_value = map[string]int32{
	"UNSPEC":      0,
	"HELLO":       1,
	"PORT_STATUS": 2,
	"PORT_CONFIG": 3,
	"FLOW_MOD":    4,
	"GROUP_MOD":   5,
	"DP_STATUS":   6,
}

func (x FFM) String() string {
	return proto.EnumName(FFM_name, int32(x))
}
func (FFM) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type DpStatus_Status int32

const (
	DpStatus_NOP   DpStatus_Status = 0
	DpStatus_ENTER DpStatus_Status = 1
	DpStatus_LEAVE DpStatus_Status = 2
)

var DpStatus_Status_name = map[int32]string{
	0: "NOP",
	1: "ENTER",
	2: "LEAVE",
}
var DpStatus_Status_value = map[string]int32{
	"NOP":   0,
	"ENTER": 1,
	"LEAVE": 2,
}

func (x DpStatus_Status) String() string {
	return proto.EnumName(DpStatus_Status_name, int32(x))
}
func (DpStatus_Status) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

type PortStatus_Status int32

const (
	PortStatus_NOP  PortStatus_Status = 0
	PortStatus_UP   PortStatus_Status = 1
	PortStatus_DOWN PortStatus_Status = 2
)

var PortStatus_Status_name = map[int32]string{
	0: "NOP",
	1: "UP",
	2: "DOWN",
}
var PortStatus_Status_value = map[string]int32{
	"NOP":  0,
	"UP":   1,
	"DOWN": 2,
}

func (x PortStatus_Status) String() string {
	return proto.EnumName(PortStatus_Status_name, int32(x))
}
func (PortStatus_Status) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

type PortConfig_Cmd int32

const (
	PortConfig_NOP    PortConfig_Cmd = 0
	PortConfig_ADD    PortConfig_Cmd = 1
	PortConfig_MODIFY PortConfig_Cmd = 2
	PortConfig_DELETE PortConfig_Cmd = 3
)

var PortConfig_Cmd_name = map[int32]string{
	0: "NOP",
	1: "ADD",
	2: "MODIFY",
	3: "DELETE",
}
var PortConfig_Cmd_value = map[string]int32{
	"NOP":    0,
	"ADD":    1,
	"MODIFY": 2,
	"DELETE": 3,
}

func (x PortConfig_Cmd) String() string {
	return proto.EnumName(PortConfig_Cmd_name, int32(x))
}
func (PortConfig_Cmd) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

type FlowMod_Cmd int32

const (
	FlowMod_NOP           FlowMod_Cmd = 0
	FlowMod_ADD           FlowMod_Cmd = 1
	FlowMod_MODIFY        FlowMod_Cmd = 2
	FlowMod_MODIFY_STRICT FlowMod_Cmd = 3
	FlowMod_DELETE        FlowMod_Cmd = 4
	FlowMod_DELETE_STRICT FlowMod_Cmd = 5
)

var FlowMod_Cmd_name = map[int32]string{
	0: "NOP",
	1: "ADD",
	2: "MODIFY",
	3: "MODIFY_STRICT",
	4: "DELETE",
	5: "DELETE_STRICT",
}
var FlowMod_Cmd_value = map[string]int32{
	"NOP":           0,
	"ADD":           1,
	"MODIFY":        2,
	"MODIFY_STRICT": 3,
	"DELETE":        4,
	"DELETE_STRICT": 5,
}

func (x FlowMod_Cmd) String() string {
	return proto.EnumName(FlowMod_Cmd_name, int32(x))
}
func (FlowMod_Cmd) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

type FlowMod_Table int32

const (
	FlowMod_INGRESS_PORT      FlowMod_Table = 0
	FlowMod_VLAN              FlowMod_Table = 10
	FlowMod_TERM_MAC          FlowMod_Table = 20
	FlowMod_L3_TYPE           FlowMod_Table = 21
	FlowMod_MPLS0             FlowMod_Table = 23
	FlowMod_MPLS1             FlowMod_Table = 24
	FlowMod_MPLS2             FlowMod_Table = 25
	FlowMod_MPLS_L3_TYPE      FlowMod_Table = 27
	FlowMod_MPLS_LABEL_TRUST  FlowMod_Table = 28
	FlowMod_MPLS_TYPE         FlowMod_Table = 29
	FlowMod_UNICAST_ROUTING   FlowMod_Table = 30
	FlowMod_MULTICAST_ROUTING FlowMod_Table = 40
	FlowMod_BRIDGING          FlowMod_Table = 50
	FlowMod_POLICY_ACL        FlowMod_Table = 60
)

var FlowMod_Table_name = map[int32]string{
	0:  "INGRESS_PORT",
	10: "VLAN",
	20: "TERM_MAC",
	21: "L3_TYPE",
	23: "MPLS0",
	24: "MPLS1",
	25: "MPLS2",
	27: "MPLS_L3_TYPE",
	28: "MPLS_LABEL_TRUST",
	29: "MPLS_TYPE",
	30: "UNICAST_ROUTING",
	40: "MULTICAST_ROUTING",
	50: "BRIDGING",
	60: "POLICY_ACL",
}
var FlowMod_Table_value = map[string]int32{
	"INGRESS_PORT":      0,
	"VLAN":              10,
	"TERM_MAC":          20,
	"L3_TYPE":           21,
	"MPLS0":             23,
	"MPLS1":             24,
	"MPLS2":             25,
	"MPLS_L3_TYPE":      27,
	"MPLS_LABEL_TRUST":  28,
	"MPLS_TYPE":         29,
	"UNICAST_ROUTING":   30,
	"MULTICAST_ROUTING": 40,
	"BRIDGING":          50,
	"POLICY_ACL":        60,
}

func (x FlowMod_Table) String() string {
	return proto.EnumName(FlowMod_Table_name, int32(x))
}
func (FlowMod_Table) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 1} }

type GroupMod_Cmd int32

const (
	GroupMod_NOP    GroupMod_Cmd = 0
	GroupMod_ADD    GroupMod_Cmd = 1
	GroupMod_MODIFY GroupMod_Cmd = 2
	GroupMod_DELETE GroupMod_Cmd = 3
)

var GroupMod_Cmd_name = map[int32]string{
	0: "NOP",
	1: "ADD",
	2: "MODIFY",
	3: "DELETE",
}
var GroupMod_Cmd_value = map[string]int32{
	"NOP":    0,
	"ADD":    1,
	"MODIFY": 2,
	"DELETE": 3,
}

func (x GroupMod_Cmd) String() string {
	return proto.EnumName(GroupMod_Cmd_name, int32(x))
}
func (GroupMod_Cmd) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

type GroupMod_GType int32

const (
	GroupMod_UNSPEC           GroupMod_GType = 0
	GroupMod_L2_INTERFACE     GroupMod_GType = 1
	GroupMod_L2_REWRITE       GroupMod_GType = 16
	GroupMod_L3_UNICAST       GroupMod_GType = 32
	GroupMod_L2_MULTICAST     GroupMod_GType = 48
	GroupMod_L2_FLOOD         GroupMod_GType = 64
	GroupMod_L3_INTERFACE     GroupMod_GType = 80
	GroupMod_L3_MULTICAST     GroupMod_GType = 96
	GroupMod_L3_ECMP          GroupMod_GType = 112
	GroupMod_L2_OVERLAY_FL_UC GroupMod_GType = 128
	GroupMod_L2_OVERLAY_FL_MC GroupMod_GType = 129
	GroupMod_L2_OVERLAY_MC_UC GroupMod_GType = 130
	GroupMod_L2_OVERLAY_MC_MC GroupMod_GType = 131
	GroupMod_MPLS_INTERFACE   GroupMod_GType = 144
	GroupMod_MPLS_L2_VPN      GroupMod_GType = 145
	GroupMod_MPLS_L3_VPN      GroupMod_GType = 146
	GroupMod_MPLS_TUNNEL1     GroupMod_GType = 147
	GroupMod_MPLS_TUNNEL2     GroupMod_GType = 148
	GroupMod_MPLS_SWAP        GroupMod_GType = 149
	GroupMod_MPLS_FF          GroupMod_GType = 166
	GroupMod_MPLS_ECMP        GroupMod_GType = 168
	GroupMod_L2_UF_INTERFACE  GroupMod_GType = 176
)

var GroupMod_GType_name = map[int32]string{
	0:   "UNSPEC",
	1:   "L2_INTERFACE",
	16:  "L2_REWRITE",
	32:  "L3_UNICAST",
	48:  "L2_MULTICAST",
	64:  "L2_FLOOD",
	80:  "L3_INTERFACE",
	96:  "L3_MULTICAST",
	112: "L3_ECMP",
	128: "L2_OVERLAY_FL_UC",
	129: "L2_OVERLAY_FL_MC",
	130: "L2_OVERLAY_MC_UC",
	131: "L2_OVERLAY_MC_MC",
	144: "MPLS_INTERFACE",
	145: "MPLS_L2_VPN",
	146: "MPLS_L3_VPN",
	147: "MPLS_TUNNEL1",
	148: "MPLS_TUNNEL2",
	149: "MPLS_SWAP",
	166: "MPLS_FF",
	168: "MPLS_ECMP",
	176: "L2_UF_INTERFACE",
}
var GroupMod_GType_value = map[string]int32{
	"UNSPEC":           0,
	"L2_INTERFACE":     1,
	"L2_REWRITE":       16,
	"L3_UNICAST":       32,
	"L2_MULTICAST":     48,
	"L2_FLOOD":         64,
	"L3_INTERFACE":     80,
	"L3_MULTICAST":     96,
	"L3_ECMP":          112,
	"L2_OVERLAY_FL_UC": 128,
	"L2_OVERLAY_FL_MC": 129,
	"L2_OVERLAY_MC_UC": 130,
	"L2_OVERLAY_MC_MC": 131,
	"MPLS_INTERFACE":   144,
	"MPLS_L2_VPN":      145,
	"MPLS_L3_VPN":      146,
	"MPLS_TUNNEL1":     147,
	"MPLS_TUNNEL2":     148,
	"MPLS_SWAP":        149,
	"MPLS_FF":          166,
	"MPLS_ECMP":        168,
	"L2_UF_INTERFACE":  176,
}

func (x GroupMod_GType) String() string {
	return proto.EnumName(GroupMod_GType_name, int32(x))
}
func (GroupMod_GType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 1} }

type VLANFlow_Action_Name int32

const (
	VLANFlow_Action_UNSPEC           VLANFlow_Action_Name = 0
	VLANFlow_Action_SET_VLAN_VID     VLANFlow_Action_Name = 1
	VLANFlow_Action_SET_VRF          VLANFlow_Action_Name = 2
	VLANFlow_Action_SET_OVID         VLANFlow_Action_Name = 3
	VLANFlow_Action_SET_MPLS_TYPE    VLANFlow_Action_Name = 4
	VLANFlow_Action_PUSH_VLAN        VLANFlow_Action_Name = 5
	VLANFlow_Action_POP_VLAN         VLANFlow_Action_Name = 6
	VLANFlow_Action_SET_MPLS_L2_TYPE VLANFlow_Action_Name = 7
	VLANFlow_Action_SET_TUNNEL_ID    VLANFlow_Action_Name = 8
)

var VLANFlow_Action_Name_name = map[int32]string{
	0: "UNSPEC",
	1: "SET_VLAN_VID",
	2: "SET_VRF",
	3: "SET_OVID",
	4: "SET_MPLS_TYPE",
	5: "PUSH_VLAN",
	6: "POP_VLAN",
	7: "SET_MPLS_L2_TYPE",
	8: "SET_TUNNEL_ID",
}
var VLANFlow_Action_Name_value = map[string]int32{
	"UNSPEC":           0,
	"SET_VLAN_VID":     1,
	"SET_VRF":          2,
	"SET_OVID":         3,
	"SET_MPLS_TYPE":    4,
	"PUSH_VLAN":        5,
	"POP_VLAN":         6,
	"SET_MPLS_L2_TYPE": 7,
	"SET_TUNNEL_ID":    8,
}

func (x VLANFlow_Action_Name) String() string {
	return proto.EnumName(VLANFlow_Action_Name_name, int32(x))
}
func (VLANFlow_Action_Name) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 1, 0} }

type TerminationMacFlow_Action_Name int32

const (
	TerminationMacFlow_Action_UNSPEC TerminationMacFlow_Action_Name = 0
	TerminationMacFlow_Action_OUTPUT TerminationMacFlow_Action_Name = 1
)

var TerminationMacFlow_Action_Name_name = map[int32]string{
	0: "UNSPEC",
	1: "OUTPUT",
}
var TerminationMacFlow_Action_Name_value = map[string]int32{
	"UNSPEC": 0,
	"OUTPUT": 1,
}

func (x TerminationMacFlow_Action_Name) String() string {
	return proto.EnumName(TerminationMacFlow_Action_Name_name, int32(x))
}
func (TerminationMacFlow_Action_Name) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{7, 1, 0}
}

type MPLSFlow_Action_Name int32

const (
	MPLSFlow_Action_UNSPEC               MPLSFlow_Action_Name = 0
	MPLSFlow_Action_POP_LABEL            MPLSFlow_Action_Name = 1
	MPLSFlow_Action_DEC_TTL              MPLSFlow_Action_Name = 2
	MPLSFlow_Action_COPY_TTL_IN          MPLSFlow_Action_Name = 3
	MPLSFlow_Action_COPY_TC_IN           MPLSFlow_Action_Name = 4
	MPLSFlow_Action_SET_VRF              MPLSFlow_Action_Name = 5
	MPLSFlow_Action_SET_MPLS_L2_PORT     MPLSFlow_Action_Name = 6
	MPLSFlow_Action_SET_MPLS_TYPE        MPLSFlow_Action_Name = 7
	MPLSFlow_Action_SET_TUNNEL_ID        MPLSFlow_Action_Name = 8
	MPLSFlow_Action_SET_QOS_INDEX        MPLSFlow_Action_Name = 9
	MPLSFlow_Action_SET_TRAFFIC_CLASS    MPLSFlow_Action_Name = 10
	MPLSFlow_Action_SET_L3_IN_PORT       MPLSFlow_Action_Name = 11
	MPLSFlow_Action_COPY_FIELD           MPLSFlow_Action_Name = 12
	MPLSFlow_Action_POP_CW_OR_ACH        MPLSFlow_Action_Name = 13
	MPLSFlow_Action_POP_VLAN             MPLSFlow_Action_Name = 14
	MPLSFlow_Action_POP_L2_HEADER        MPLSFlow_Action_Name = 15
	MPLSFlow_Action_SET_LMEP_ID          MPLSFlow_Action_Name = 16
	MPLSFlow_Action_SET_PROTECTION_INDEX MPLSFlow_Action_Name = 17
)

var MPLSFlow_Action_Name_name = map[int32]string{
	0:  "UNSPEC",
	1:  "POP_LABEL",
	2:  "DEC_TTL",
	3:  "COPY_TTL_IN",
	4:  "COPY_TC_IN",
	5:  "SET_VRF",
	6:  "SET_MPLS_L2_PORT",
	7:  "SET_MPLS_TYPE",
	8:  "SET_TUNNEL_ID",
	9:  "SET_QOS_INDEX",
	10: "SET_TRAFFIC_CLASS",
	11: "SET_L3_IN_PORT",
	12: "COPY_FIELD",
	13: "POP_CW_OR_ACH",
	14: "POP_VLAN",
	15: "POP_L2_HEADER",
	16: "SET_LMEP_ID",
	17: "SET_PROTECTION_INDEX",
}
var MPLSFlow_Action_Name_value = map[string]int32{
	"UNSPEC":               0,
	"POP_LABEL":            1,
	"DEC_TTL":              2,
	"COPY_TTL_IN":          3,
	"COPY_TC_IN":           4,
	"SET_VRF":              5,
	"SET_MPLS_L2_PORT":     6,
	"SET_MPLS_TYPE":        7,
	"SET_TUNNEL_ID":        8,
	"SET_QOS_INDEX":        9,
	"SET_TRAFFIC_CLASS":    10,
	"SET_L3_IN_PORT":       11,
	"COPY_FIELD":           12,
	"POP_CW_OR_ACH":        13,
	"POP_VLAN":             14,
	"POP_L2_HEADER":        15,
	"SET_LMEP_ID":          16,
	"SET_PROTECTION_INDEX": 17,
}

func (x MPLSFlow_Action_Name) String() string {
	return proto.EnumName(MPLSFlow_Action_Name_name, int32(x))
}
func (MPLSFlow_Action_Name) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 1, 0} }

type UnicastRoutingFlow_Action_Name int32

const (
	UnicastRoutingFlow_Action_UNSPEC        UnicastRoutingFlow_Action_Name = 0
	UnicastRoutingFlow_Action_OUTPUT        UnicastRoutingFlow_Action_Name = 1
	UnicastRoutingFlow_Action_CLEAR_ACTIONS UnicastRoutingFlow_Action_Name = 2
	UnicastRoutingFlow_Action_DEC_TTL       UnicastRoutingFlow_Action_Name = 3
)

var UnicastRoutingFlow_Action_Name_name = map[int32]string{
	0: "UNSPEC",
	1: "OUTPUT",
	2: "CLEAR_ACTIONS",
	3: "DEC_TTL",
}
var UnicastRoutingFlow_Action_Name_value = map[string]int32{
	"UNSPEC":        0,
	"OUTPUT":        1,
	"CLEAR_ACTIONS": 2,
	"DEC_TTL":       3,
}

func (x UnicastRoutingFlow_Action_Name) String() string {
	return proto.EnumName(UnicastRoutingFlow_Action_Name_name, int32(x))
}
func (UnicastRoutingFlow_Action_Name) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{9, 1, 0}
}

type BridgingFlow_Action_Name int32

const (
	BridgingFlow_Action_UNSPEC BridgingFlow_Action_Name = 0
	BridgingFlow_Action_OUTPUT BridgingFlow_Action_Name = 1
)

var BridgingFlow_Action_Name_name = map[int32]string{
	0: "UNSPEC",
	1: "OUTPUT",
}
var BridgingFlow_Action_Name_value = map[string]int32{
	"UNSPEC": 0,
	"OUTPUT": 1,
}

func (x BridgingFlow_Action_Name) String() string {
	return proto.EnumName(BridgingFlow_Action_Name_name, int32(x))
}
func (BridgingFlow_Action_Name) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{10, 1, 0}
}

type PolicyACLFlow_Action_Name int32

const (
	PolicyACLFlow_Action_UNSPEC PolicyACLFlow_Action_Name = 0
	PolicyACLFlow_Action_OUTPUT PolicyACLFlow_Action_Name = 1
)

var PolicyACLFlow_Action_Name_name = map[int32]string{
	0: "UNSPEC",
	1: "OUTPUT",
}
var PolicyACLFlow_Action_Name_value = map[string]int32{
	"UNSPEC": 0,
	"OUTPUT": 1,
}

func (x PolicyACLFlow_Action_Name) String() string {
	return proto.EnumName(PolicyACLFlow_Action_Name_name, int32(x))
}
func (PolicyACLFlow_Action_Name) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{11, 1, 0}
}

type Hello struct {
	ReId string `protobuf:"bytes,1,opt,name=re_id,json=reId" json:"re_id,omitempty"`
}

func (m *Hello) Reset()                    { *m = Hello{} }
func (m *Hello) String() string            { return proto.CompactTextString(m) }
func (*Hello) ProtoMessage()               {}
func (*Hello) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Hello) GetReId() string {
	if m != nil {
		return m.ReId
	}
	return ""
}

type DpStatus struct {
	Status DpStatus_Status `protobuf:"varint,1,opt,name=status,enum=fibcapi.DpStatus_Status" json:"status,omitempty"`
	ReId   string          `protobuf:"bytes,2,opt,name=re_id,json=reId" json:"re_id,omitempty"`
}

func (m *DpStatus) Reset()                    { *m = DpStatus{} }
func (m *DpStatus) String() string            { return proto.CompactTextString(m) }
func (*DpStatus) ProtoMessage()               {}
func (*DpStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *DpStatus) GetStatus() DpStatus_Status {
	if m != nil {
		return m.Status
	}
	return DpStatus_NOP
}

func (m *DpStatus) GetReId() string {
	if m != nil {
		return m.ReId
	}
	return ""
}

type PortStatus struct {
	Status PortStatus_Status `protobuf:"varint,1,opt,name=status,enum=fibcapi.PortStatus_Status" json:"status,omitempty"`
	ReId   string            `protobuf:"bytes,2,opt,name=re_id,json=reId" json:"re_id,omitempty"`
	PortId uint32            `protobuf:"varint,3,opt,name=port_id,json=portId" json:"port_id,omitempty"`
	Ifname string            `protobuf:"bytes,4,opt,name=ifname" json:"ifname,omitempty"`
}

func (m *PortStatus) Reset()                    { *m = PortStatus{} }
func (m *PortStatus) String() string            { return proto.CompactTextString(m) }
func (*PortStatus) ProtoMessage()               {}
func (*PortStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *PortStatus) GetStatus() PortStatus_Status {
	if m != nil {
		return m.Status
	}
	return PortStatus_NOP
}

func (m *PortStatus) GetReId() string {
	if m != nil {
		return m.ReId
	}
	return ""
}

func (m *PortStatus) GetPortId() uint32 {
	if m != nil {
		return m.PortId
	}
	return 0
}

func (m *PortStatus) GetIfname() string {
	if m != nil {
		return m.Ifname
	}
	return ""
}

type PortConfig struct {
	Cmd    PortConfig_Cmd    `protobuf:"varint,1,opt,name=cmd,enum=fibcapi.PortConfig_Cmd" json:"cmd,omitempty"`
	ReId   string            `protobuf:"bytes,2,opt,name=re_id,json=reId" json:"re_id,omitempty"`
	Ifname string            `protobuf:"bytes,3,opt,name=ifname" json:"ifname,omitempty"`
	PortId uint32            `protobuf:"varint,4,opt,name=port_id,json=portId" json:"port_id,omitempty"`
	Link   string            `protobuf:"bytes,5,opt,name=link" json:"link,omitempty"`
	Slaves []string          `protobuf:"bytes,6,rep,name=slaves" json:"slaves,omitempty"`
	Status PortStatus_Status `protobuf:"varint,7,opt,name=status,enum=fibcapi.PortStatus_Status" json:"status,omitempty"`
}

func (m *PortConfig) Reset()                    { *m = PortConfig{} }
func (m *PortConfig) String() string            { return proto.CompactTextString(m) }
func (*PortConfig) ProtoMessage()               {}
func (*PortConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *PortConfig) GetCmd() PortConfig_Cmd {
	if m != nil {
		return m.Cmd
	}
	return PortConfig_NOP
}

func (m *PortConfig) GetReId() string {
	if m != nil {
		return m.ReId
	}
	return ""
}

func (m *PortConfig) GetIfname() string {
	if m != nil {
		return m.Ifname
	}
	return ""
}

func (m *PortConfig) GetPortId() uint32 {
	if m != nil {
		return m.PortId
	}
	return 0
}

func (m *PortConfig) GetLink() string {
	if m != nil {
		return m.Link
	}
	return ""
}

func (m *PortConfig) GetSlaves() []string {
	if m != nil {
		return m.Slaves
	}
	return nil
}

func (m *PortConfig) GetStatus() PortStatus_Status {
	if m != nil {
		return m.Status
	}
	return PortStatus_NOP
}

type FlowMod struct {
	Cmd   FlowMod_Cmd   `protobuf:"varint,1,opt,name=cmd,enum=fibcapi.FlowMod_Cmd" json:"cmd,omitempty"`
	Table FlowMod_Table `protobuf:"varint,2,opt,name=table,enum=fibcapi.FlowMod_Table" json:"table,omitempty"`
	ReId  string        `protobuf:"bytes,3,opt,name=re_id,json=reId" json:"re_id,omitempty"`
	// Types that are valid to be assigned to Entry:
	//	*FlowMod_Vlan
	//	*FlowMod_TermMac
	//	*FlowMod_Mpls1
	//	*FlowMod_Unicast
	//	*FlowMod_Bridging
	//	*FlowMod_Acl
	Entry isFlowMod_Entry `protobuf_oneof:"entry"`
}

func (m *FlowMod) Reset()                    { *m = FlowMod{} }
func (m *FlowMod) String() string            { return proto.CompactTextString(m) }
func (*FlowMod) ProtoMessage()               {}
func (*FlowMod) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type isFlowMod_Entry interface {
	isFlowMod_Entry()
}

type FlowMod_Vlan struct {
	Vlan *VLANFlow `protobuf:"bytes,4,opt,name=vlan,oneof"`
}
type FlowMod_TermMac struct {
	TermMac *TerminationMacFlow `protobuf:"bytes,5,opt,name=term_mac,json=termMac,oneof"`
}
type FlowMod_Mpls1 struct {
	Mpls1 *MPLSFlow `protobuf:"bytes,6,opt,name=mpls1,oneof"`
}
type FlowMod_Unicast struct {
	Unicast *UnicastRoutingFlow `protobuf:"bytes,7,opt,name=unicast,oneof"`
}
type FlowMod_Bridging struct {
	Bridging *BridgingFlow `protobuf:"bytes,8,opt,name=bridging,oneof"`
}
type FlowMod_Acl struct {
	Acl *PolicyACLFlow `protobuf:"bytes,9,opt,name=acl,oneof"`
}

func (*FlowMod_Vlan) isFlowMod_Entry()     {}
func (*FlowMod_TermMac) isFlowMod_Entry()  {}
func (*FlowMod_Mpls1) isFlowMod_Entry()    {}
func (*FlowMod_Unicast) isFlowMod_Entry()  {}
func (*FlowMod_Bridging) isFlowMod_Entry() {}
func (*FlowMod_Acl) isFlowMod_Entry()      {}

func (m *FlowMod) GetEntry() isFlowMod_Entry {
	if m != nil {
		return m.Entry
	}
	return nil
}

func (m *FlowMod) GetCmd() FlowMod_Cmd {
	if m != nil {
		return m.Cmd
	}
	return FlowMod_NOP
}

func (m *FlowMod) GetTable() FlowMod_Table {
	if m != nil {
		return m.Table
	}
	return FlowMod_INGRESS_PORT
}

func (m *FlowMod) GetReId() string {
	if m != nil {
		return m.ReId
	}
	return ""
}

func (m *FlowMod) GetVlan() *VLANFlow {
	if x, ok := m.GetEntry().(*FlowMod_Vlan); ok {
		return x.Vlan
	}
	return nil
}

func (m *FlowMod) GetTermMac() *TerminationMacFlow {
	if x, ok := m.GetEntry().(*FlowMod_TermMac); ok {
		return x.TermMac
	}
	return nil
}

func (m *FlowMod) GetMpls1() *MPLSFlow {
	if x, ok := m.GetEntry().(*FlowMod_Mpls1); ok {
		return x.Mpls1
	}
	return nil
}

func (m *FlowMod) GetUnicast() *UnicastRoutingFlow {
	if x, ok := m.GetEntry().(*FlowMod_Unicast); ok {
		return x.Unicast
	}
	return nil
}

func (m *FlowMod) GetBridging() *BridgingFlow {
	if x, ok := m.GetEntry().(*FlowMod_Bridging); ok {
		return x.Bridging
	}
	return nil
}

func (m *FlowMod) GetAcl() *PolicyACLFlow {
	if x, ok := m.GetEntry().(*FlowMod_Acl); ok {
		return x.Acl
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FlowMod) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FlowMod_OneofMarshaler, _FlowMod_OneofUnmarshaler, _FlowMod_OneofSizer, []interface{}{
		(*FlowMod_Vlan)(nil),
		(*FlowMod_TermMac)(nil),
		(*FlowMod_Mpls1)(nil),
		(*FlowMod_Unicast)(nil),
		(*FlowMod_Bridging)(nil),
		(*FlowMod_Acl)(nil),
	}
}

func _FlowMod_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FlowMod)
	// entry
	switch x := m.Entry.(type) {
	case *FlowMod_Vlan:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Vlan); err != nil {
			return err
		}
	case *FlowMod_TermMac:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TermMac); err != nil {
			return err
		}
	case *FlowMod_Mpls1:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Mpls1); err != nil {
			return err
		}
	case *FlowMod_Unicast:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Unicast); err != nil {
			return err
		}
	case *FlowMod_Bridging:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Bridging); err != nil {
			return err
		}
	case *FlowMod_Acl:
		b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Acl); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FlowMod.Entry has unexpected type %T", x)
	}
	return nil
}

func _FlowMod_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FlowMod)
	switch tag {
	case 4: // entry.vlan
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VLANFlow)
		err := b.DecodeMessage(msg)
		m.Entry = &FlowMod_Vlan{msg}
		return true, err
	case 5: // entry.term_mac
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TerminationMacFlow)
		err := b.DecodeMessage(msg)
		m.Entry = &FlowMod_TermMac{msg}
		return true, err
	case 6: // entry.mpls1
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MPLSFlow)
		err := b.DecodeMessage(msg)
		m.Entry = &FlowMod_Mpls1{msg}
		return true, err
	case 7: // entry.unicast
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UnicastRoutingFlow)
		err := b.DecodeMessage(msg)
		m.Entry = &FlowMod_Unicast{msg}
		return true, err
	case 8: // entry.bridging
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BridgingFlow)
		err := b.DecodeMessage(msg)
		m.Entry = &FlowMod_Bridging{msg}
		return true, err
	case 9: // entry.acl
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PolicyACLFlow)
		err := b.DecodeMessage(msg)
		m.Entry = &FlowMod_Acl{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FlowMod_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FlowMod)
	// entry
	switch x := m.Entry.(type) {
	case *FlowMod_Vlan:
		s := proto.Size(x.Vlan)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FlowMod_TermMac:
		s := proto.Size(x.TermMac)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FlowMod_Mpls1:
		s := proto.Size(x.Mpls1)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FlowMod_Unicast:
		s := proto.Size(x.Unicast)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FlowMod_Bridging:
		s := proto.Size(x.Bridging)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FlowMod_Acl:
		s := proto.Size(x.Acl)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type GroupMod struct {
	Cmd   GroupMod_Cmd   `protobuf:"varint,1,opt,name=cmd,enum=fibcapi.GroupMod_Cmd" json:"cmd,omitempty"`
	GType GroupMod_GType `protobuf:"varint,2,opt,name=g_type,json=gType,enum=fibcapi.GroupMod_GType" json:"g_type,omitempty"`
	ReId  string         `protobuf:"bytes,3,opt,name=re_id,json=reId" json:"re_id,omitempty"`
	// Types that are valid to be assigned to Entry:
	//	*GroupMod_L2Iface
	//	*GroupMod_L3Unicast
	//	*GroupMod_MplsIface
	//	*GroupMod_MplsLabel
	Entry isGroupMod_Entry `protobuf_oneof:"entry"`
}

func (m *GroupMod) Reset()                    { *m = GroupMod{} }
func (m *GroupMod) String() string            { return proto.CompactTextString(m) }
func (*GroupMod) ProtoMessage()               {}
func (*GroupMod) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type isGroupMod_Entry interface {
	isGroupMod_Entry()
}

type GroupMod_L2Iface struct {
	L2Iface *L2InterfaceGroup `protobuf:"bytes,4,opt,name=l2_iface,json=l2Iface,oneof"`
}
type GroupMod_L3Unicast struct {
	L3Unicast *L3UnicastGroup `protobuf:"bytes,5,opt,name=l3_unicast,json=l3Unicast,oneof"`
}
type GroupMod_MplsIface struct {
	MplsIface *MPLSInterfaceGroup `protobuf:"bytes,6,opt,name=mpls_iface,json=mplsIface,oneof"`
}
type GroupMod_MplsLabel struct {
	MplsLabel *MPLSLabelGroup `protobuf:"bytes,7,opt,name=mpls_label,json=mplsLabel,oneof"`
}

func (*GroupMod_L2Iface) isGroupMod_Entry()   {}
func (*GroupMod_L3Unicast) isGroupMod_Entry() {}
func (*GroupMod_MplsIface) isGroupMod_Entry() {}
func (*GroupMod_MplsLabel) isGroupMod_Entry() {}

func (m *GroupMod) GetEntry() isGroupMod_Entry {
	if m != nil {
		return m.Entry
	}
	return nil
}

func (m *GroupMod) GetCmd() GroupMod_Cmd {
	if m != nil {
		return m.Cmd
	}
	return GroupMod_NOP
}

func (m *GroupMod) GetGType() GroupMod_GType {
	if m != nil {
		return m.GType
	}
	return GroupMod_UNSPEC
}

func (m *GroupMod) GetReId() string {
	if m != nil {
		return m.ReId
	}
	return ""
}

func (m *GroupMod) GetL2Iface() *L2InterfaceGroup {
	if x, ok := m.GetEntry().(*GroupMod_L2Iface); ok {
		return x.L2Iface
	}
	return nil
}

func (m *GroupMod) GetL3Unicast() *L3UnicastGroup {
	if x, ok := m.GetEntry().(*GroupMod_L3Unicast); ok {
		return x.L3Unicast
	}
	return nil
}

func (m *GroupMod) GetMplsIface() *MPLSInterfaceGroup {
	if x, ok := m.GetEntry().(*GroupMod_MplsIface); ok {
		return x.MplsIface
	}
	return nil
}

func (m *GroupMod) GetMplsLabel() *MPLSLabelGroup {
	if x, ok := m.GetEntry().(*GroupMod_MplsLabel); ok {
		return x.MplsLabel
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GroupMod) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GroupMod_OneofMarshaler, _GroupMod_OneofUnmarshaler, _GroupMod_OneofSizer, []interface{}{
		(*GroupMod_L2Iface)(nil),
		(*GroupMod_L3Unicast)(nil),
		(*GroupMod_MplsIface)(nil),
		(*GroupMod_MplsLabel)(nil),
	}
}

func _GroupMod_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GroupMod)
	// entry
	switch x := m.Entry.(type) {
	case *GroupMod_L2Iface:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.L2Iface); err != nil {
			return err
		}
	case *GroupMod_L3Unicast:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.L3Unicast); err != nil {
			return err
		}
	case *GroupMod_MplsIface:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MplsIface); err != nil {
			return err
		}
	case *GroupMod_MplsLabel:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MplsLabel); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GroupMod.Entry has unexpected type %T", x)
	}
	return nil
}

func _GroupMod_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GroupMod)
	switch tag {
	case 4: // entry.l2_iface
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(L2InterfaceGroup)
		err := b.DecodeMessage(msg)
		m.Entry = &GroupMod_L2Iface{msg}
		return true, err
	case 5: // entry.l3_unicast
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(L3UnicastGroup)
		err := b.DecodeMessage(msg)
		m.Entry = &GroupMod_L3Unicast{msg}
		return true, err
	case 6: // entry.mpls_iface
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MPLSInterfaceGroup)
		err := b.DecodeMessage(msg)
		m.Entry = &GroupMod_MplsIface{msg}
		return true, err
	case 7: // entry.mpls_label
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MPLSLabelGroup)
		err := b.DecodeMessage(msg)
		m.Entry = &GroupMod_MplsLabel{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GroupMod_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GroupMod)
	// entry
	switch x := m.Entry.(type) {
	case *GroupMod_L2Iface:
		s := proto.Size(x.L2Iface)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GroupMod_L3Unicast:
		s := proto.Size(x.L3Unicast)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GroupMod_MplsIface:
		s := proto.Size(x.MplsIface)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GroupMod_MplsLabel:
		s := proto.Size(x.MplsLabel)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type VLANFlow struct {
	Match     *VLANFlow_Match    `protobuf:"bytes,1,opt,name=match" json:"match,omitempty"`
	Actions   []*VLANFlow_Action `protobuf:"bytes,2,rep,name=actions" json:"actions,omitempty"`
	GotoTable uint32             `protobuf:"varint,3,opt,name=goto_table,json=gotoTable" json:"goto_table,omitempty"`
}

func (m *VLANFlow) Reset()                    { *m = VLANFlow{} }
func (m *VLANFlow) String() string            { return proto.CompactTextString(m) }
func (*VLANFlow) ProtoMessage()               {}
func (*VLANFlow) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *VLANFlow) GetMatch() *VLANFlow_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *VLANFlow) GetActions() []*VLANFlow_Action {
	if m != nil {
		return m.Actions
	}
	return nil
}

func (m *VLANFlow) GetGotoTable() uint32 {
	if m != nil {
		return m.GotoTable
	}
	return 0
}

type VLANFlow_Match struct {
	InPort  uint32 `protobuf:"varint,1,opt,name=in_port,json=inPort" json:"in_port,omitempty"`
	Vid     uint32 `protobuf:"varint,2,opt,name=vid" json:"vid,omitempty"`
	VidMask uint32 `protobuf:"varint,3,opt,name=vid_mask,json=vidMask" json:"vid_mask,omitempty"`
}

func (m *VLANFlow_Match) Reset()                    { *m = VLANFlow_Match{} }
func (m *VLANFlow_Match) String() string            { return proto.CompactTextString(m) }
func (*VLANFlow_Match) ProtoMessage()               {}
func (*VLANFlow_Match) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 0} }

func (m *VLANFlow_Match) GetInPort() uint32 {
	if m != nil {
		return m.InPort
	}
	return 0
}

func (m *VLANFlow_Match) GetVid() uint32 {
	if m != nil {
		return m.Vid
	}
	return 0
}

func (m *VLANFlow_Match) GetVidMask() uint32 {
	if m != nil {
		return m.VidMask
	}
	return 0
}

type VLANFlow_Action struct {
	Name  VLANFlow_Action_Name `protobuf:"varint,1,opt,name=name,enum=fibcapi.VLANFlow_Action_Name" json:"name,omitempty"`
	Value uint32               `protobuf:"varint,2,opt,name=value" json:"value,omitempty"`
}

func (m *VLANFlow_Action) Reset()                    { *m = VLANFlow_Action{} }
func (m *VLANFlow_Action) String() string            { return proto.CompactTextString(m) }
func (*VLANFlow_Action) ProtoMessage()               {}
func (*VLANFlow_Action) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 1} }

func (m *VLANFlow_Action) GetName() VLANFlow_Action_Name {
	if m != nil {
		return m.Name
	}
	return VLANFlow_Action_UNSPEC
}

func (m *VLANFlow_Action) GetValue() uint32 {
	if m != nil {
		return m.Value
	}
	return 0
}

type TerminationMacFlow struct {
	Match     *TerminationMacFlow_Match    `protobuf:"bytes,1,opt,name=match" json:"match,omitempty"`
	Actions   []*TerminationMacFlow_Action `protobuf:"bytes,2,rep,name=actions" json:"actions,omitempty"`
	GotoTable uint32                       `protobuf:"varint,3,opt,name=goto_table,json=gotoTable" json:"goto_table,omitempty"`
}

func (m *TerminationMacFlow) Reset()                    { *m = TerminationMacFlow{} }
func (m *TerminationMacFlow) String() string            { return proto.CompactTextString(m) }
func (*TerminationMacFlow) ProtoMessage()               {}
func (*TerminationMacFlow) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *TerminationMacFlow) GetMatch() *TerminationMacFlow_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *TerminationMacFlow) GetActions() []*TerminationMacFlow_Action {
	if m != nil {
		return m.Actions
	}
	return nil
}

func (m *TerminationMacFlow) GetGotoTable() uint32 {
	if m != nil {
		return m.GotoTable
	}
	return 0
}

type TerminationMacFlow_Match struct {
	InPort  uint32 `protobuf:"varint,1,opt,name=in_port,json=inPort" json:"in_port,omitempty"`
	EthType uint32 `protobuf:"varint,2,opt,name=eth_type,json=ethType" json:"eth_type,omitempty"`
	EthDst  string `protobuf:"bytes,3,opt,name=eth_dst,json=ethDst" json:"eth_dst,omitempty"`
	VlanVid uint32 `protobuf:"varint,4,opt,name=vlan_vid,json=vlanVid" json:"vlan_vid,omitempty"`
}

func (m *TerminationMacFlow_Match) Reset()                    { *m = TerminationMacFlow_Match{} }
func (m *TerminationMacFlow_Match) String() string            { return proto.CompactTextString(m) }
func (*TerminationMacFlow_Match) ProtoMessage()               {}
func (*TerminationMacFlow_Match) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 0} }

func (m *TerminationMacFlow_Match) GetInPort() uint32 {
	if m != nil {
		return m.InPort
	}
	return 0
}

func (m *TerminationMacFlow_Match) GetEthType() uint32 {
	if m != nil {
		return m.EthType
	}
	return 0
}

func (m *TerminationMacFlow_Match) GetEthDst() string {
	if m != nil {
		return m.EthDst
	}
	return ""
}

func (m *TerminationMacFlow_Match) GetVlanVid() uint32 {
	if m != nil {
		return m.VlanVid
	}
	return 0
}

type TerminationMacFlow_Action struct {
	Name  TerminationMacFlow_Action_Name `protobuf:"varint,1,opt,name=name,enum=fibcapi.TerminationMacFlow_Action_Name" json:"name,omitempty"`
	Value uint32                         `protobuf:"varint,2,opt,name=value" json:"value,omitempty"`
}

func (m *TerminationMacFlow_Action) Reset()                    { *m = TerminationMacFlow_Action{} }
func (m *TerminationMacFlow_Action) String() string            { return proto.CompactTextString(m) }
func (*TerminationMacFlow_Action) ProtoMessage()               {}
func (*TerminationMacFlow_Action) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 1} }

func (m *TerminationMacFlow_Action) GetName() TerminationMacFlow_Action_Name {
	if m != nil {
		return m.Name
	}
	return TerminationMacFlow_Action_UNSPEC
}

func (m *TerminationMacFlow_Action) GetValue() uint32 {
	if m != nil {
		return m.Value
	}
	return 0
}

type MPLSFlow struct {
	Match     *MPLSFlow_Match    `protobuf:"bytes,1,opt,name=match" json:"match,omitempty"`
	Actions   []*MPLSFlow_Action `protobuf:"bytes,2,rep,name=actions" json:"actions,omitempty"`
	GType     GroupMod_GType     `protobuf:"varint,3,opt,name=g_type,json=gType,enum=fibcapi.GroupMod_GType" json:"g_type,omitempty"`
	GId       uint32             `protobuf:"varint,4,opt,name=g_id,json=gId" json:"g_id,omitempty"`
	GotoTable uint32             `protobuf:"varint,5,opt,name=goto_table,json=gotoTable" json:"goto_table,omitempty"`
}

func (m *MPLSFlow) Reset()                    { *m = MPLSFlow{} }
func (m *MPLSFlow) String() string            { return proto.CompactTextString(m) }
func (*MPLSFlow) ProtoMessage()               {}
func (*MPLSFlow) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *MPLSFlow) GetMatch() *MPLSFlow_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *MPLSFlow) GetActions() []*MPLSFlow_Action {
	if m != nil {
		return m.Actions
	}
	return nil
}

func (m *MPLSFlow) GetGType() GroupMod_GType {
	if m != nil {
		return m.GType
	}
	return GroupMod_UNSPEC
}

func (m *MPLSFlow) GetGId() uint32 {
	if m != nil {
		return m.GId
	}
	return 0
}

func (m *MPLSFlow) GetGotoTable() uint32 {
	if m != nil {
		return m.GotoTable
	}
	return 0
}

type MPLSFlow_Match struct {
	Bos   bool   `protobuf:"varint,1,opt,name=bos" json:"bos,omitempty"`
	Label uint32 `protobuf:"varint,2,opt,name=label" json:"label,omitempty"`
}

func (m *MPLSFlow_Match) Reset()                    { *m = MPLSFlow_Match{} }
func (m *MPLSFlow_Match) String() string            { return proto.CompactTextString(m) }
func (*MPLSFlow_Match) ProtoMessage()               {}
func (*MPLSFlow_Match) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 0} }

func (m *MPLSFlow_Match) GetBos() bool {
	if m != nil {
		return m.Bos
	}
	return false
}

func (m *MPLSFlow_Match) GetLabel() uint32 {
	if m != nil {
		return m.Label
	}
	return 0
}

type MPLSFlow_Action struct {
	Name  MPLSFlow_Action_Name `protobuf:"varint,1,opt,name=name,enum=fibcapi.MPLSFlow_Action_Name" json:"name,omitempty"`
	Value uint32               `protobuf:"varint,2,opt,name=value" json:"value,omitempty"`
}

func (m *MPLSFlow_Action) Reset()                    { *m = MPLSFlow_Action{} }
func (m *MPLSFlow_Action) String() string            { return proto.CompactTextString(m) }
func (*MPLSFlow_Action) ProtoMessage()               {}
func (*MPLSFlow_Action) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 1} }

func (m *MPLSFlow_Action) GetName() MPLSFlow_Action_Name {
	if m != nil {
		return m.Name
	}
	return MPLSFlow_Action_UNSPEC
}

func (m *MPLSFlow_Action) GetValue() uint32 {
	if m != nil {
		return m.Value
	}
	return 0
}

type UnicastRoutingFlow struct {
	Match  *UnicastRoutingFlow_Match  `protobuf:"bytes,1,opt,name=match" json:"match,omitempty"`
	Action *UnicastRoutingFlow_Action `protobuf:"bytes,2,opt,name=action" json:"action,omitempty"`
	GType  GroupMod_GType             `protobuf:"varint,3,opt,name=g_type,json=gType,enum=fibcapi.GroupMod_GType" json:"g_type,omitempty"`
	GId    uint32                     `protobuf:"varint,4,opt,name=g_id,json=gId" json:"g_id,omitempty"`
}

func (m *UnicastRoutingFlow) Reset()                    { *m = UnicastRoutingFlow{} }
func (m *UnicastRoutingFlow) String() string            { return proto.CompactTextString(m) }
func (*UnicastRoutingFlow) ProtoMessage()               {}
func (*UnicastRoutingFlow) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *UnicastRoutingFlow) GetMatch() *UnicastRoutingFlow_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *UnicastRoutingFlow) GetAction() *UnicastRoutingFlow_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *UnicastRoutingFlow) GetGType() GroupMod_GType {
	if m != nil {
		return m.GType
	}
	return GroupMod_UNSPEC
}

func (m *UnicastRoutingFlow) GetGId() uint32 {
	if m != nil {
		return m.GId
	}
	return 0
}

type UnicastRoutingFlow_Match struct {
	IpDst string `protobuf:"bytes,1,opt,name=ip_dst,json=ipDst" json:"ip_dst,omitempty"`
	Vrf   uint32 `protobuf:"varint,2,opt,name=vrf" json:"vrf,omitempty"`
}

func (m *UnicastRoutingFlow_Match) Reset()                    { *m = UnicastRoutingFlow_Match{} }
func (m *UnicastRoutingFlow_Match) String() string            { return proto.CompactTextString(m) }
func (*UnicastRoutingFlow_Match) ProtoMessage()               {}
func (*UnicastRoutingFlow_Match) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 0} }

func (m *UnicastRoutingFlow_Match) GetIpDst() string {
	if m != nil {
		return m.IpDst
	}
	return ""
}

func (m *UnicastRoutingFlow_Match) GetVrf() uint32 {
	if m != nil {
		return m.Vrf
	}
	return 0
}

type UnicastRoutingFlow_Action struct {
	Name  UnicastRoutingFlow_Action_Name `protobuf:"varint,1,opt,name=name,enum=fibcapi.UnicastRoutingFlow_Action_Name" json:"name,omitempty"`
	Value uint32                         `protobuf:"varint,2,opt,name=value" json:"value,omitempty"`
}

func (m *UnicastRoutingFlow_Action) Reset()                    { *m = UnicastRoutingFlow_Action{} }
func (m *UnicastRoutingFlow_Action) String() string            { return proto.CompactTextString(m) }
func (*UnicastRoutingFlow_Action) ProtoMessage()               {}
func (*UnicastRoutingFlow_Action) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 1} }

func (m *UnicastRoutingFlow_Action) GetName() UnicastRoutingFlow_Action_Name {
	if m != nil {
		return m.Name
	}
	return UnicastRoutingFlow_Action_UNSPEC
}

func (m *UnicastRoutingFlow_Action) GetValue() uint32 {
	if m != nil {
		return m.Value
	}
	return 0
}

type BridgingFlow struct {
	Match  *BridgingFlow_Match  `protobuf:"bytes,1,opt,name=match" json:"match,omitempty"`
	Action *BridgingFlow_Action `protobuf:"bytes,2,opt,name=action" json:"action,omitempty"`
}

func (m *BridgingFlow) Reset()                    { *m = BridgingFlow{} }
func (m *BridgingFlow) String() string            { return proto.CompactTextString(m) }
func (*BridgingFlow) ProtoMessage()               {}
func (*BridgingFlow) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *BridgingFlow) GetMatch() *BridgingFlow_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *BridgingFlow) GetAction() *BridgingFlow_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

type BridgingFlow_Match struct {
	EthDst   string `protobuf:"bytes,1,opt,name=eth_dst,json=ethDst" json:"eth_dst,omitempty"`
	VlanVid  uint32 `protobuf:"varint,2,opt,name=vlan_vid,json=vlanVid" json:"vlan_vid,omitempty"`
	TunnelId uint32 `protobuf:"varint,3,opt,name=tunnel_id,json=tunnelId" json:"tunnel_id,omitempty"`
}

func (m *BridgingFlow_Match) Reset()                    { *m = BridgingFlow_Match{} }
func (m *BridgingFlow_Match) String() string            { return proto.CompactTextString(m) }
func (*BridgingFlow_Match) ProtoMessage()               {}
func (*BridgingFlow_Match) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 0} }

func (m *BridgingFlow_Match) GetEthDst() string {
	if m != nil {
		return m.EthDst
	}
	return ""
}

func (m *BridgingFlow_Match) GetVlanVid() uint32 {
	if m != nil {
		return m.VlanVid
	}
	return 0
}

func (m *BridgingFlow_Match) GetTunnelId() uint32 {
	if m != nil {
		return m.TunnelId
	}
	return 0
}

type BridgingFlow_Action struct {
	Name  BridgingFlow_Action_Name `protobuf:"varint,1,opt,name=name,enum=fibcapi.BridgingFlow_Action_Name" json:"name,omitempty"`
	Value uint32                   `protobuf:"varint,2,opt,name=value" json:"value,omitempty"`
}

func (m *BridgingFlow_Action) Reset()                    { *m = BridgingFlow_Action{} }
func (m *BridgingFlow_Action) String() string            { return proto.CompactTextString(m) }
func (*BridgingFlow_Action) ProtoMessage()               {}
func (*BridgingFlow_Action) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 1} }

func (m *BridgingFlow_Action) GetName() BridgingFlow_Action_Name {
	if m != nil {
		return m.Name
	}
	return BridgingFlow_Action_UNSPEC
}

func (m *BridgingFlow_Action) GetValue() uint32 {
	if m != nil {
		return m.Value
	}
	return 0
}

type PolicyACLFlow struct {
	Match  *PolicyACLFlow_Match  `protobuf:"bytes,1,opt,name=match" json:"match,omitempty"`
	Action *PolicyACLFlow_Action `protobuf:"bytes,2,opt,name=action" json:"action,omitempty"`
}

func (m *PolicyACLFlow) Reset()                    { *m = PolicyACLFlow{} }
func (m *PolicyACLFlow) String() string            { return proto.CompactTextString(m) }
func (*PolicyACLFlow) ProtoMessage()               {}
func (*PolicyACLFlow) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *PolicyACLFlow) GetMatch() *PolicyACLFlow_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *PolicyACLFlow) GetAction() *PolicyACLFlow_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

type PolicyACLFlow_Match struct {
	IpDst string `protobuf:"bytes,1,opt,name=ip_dst,json=ipDst" json:"ip_dst,omitempty"`
	Vrf   uint32 `protobuf:"varint,2,opt,name=vrf" json:"vrf,omitempty"`
}

func (m *PolicyACLFlow_Match) Reset()                    { *m = PolicyACLFlow_Match{} }
func (m *PolicyACLFlow_Match) String() string            { return proto.CompactTextString(m) }
func (*PolicyACLFlow_Match) ProtoMessage()               {}
func (*PolicyACLFlow_Match) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11, 0} }

func (m *PolicyACLFlow_Match) GetIpDst() string {
	if m != nil {
		return m.IpDst
	}
	return ""
}

func (m *PolicyACLFlow_Match) GetVrf() uint32 {
	if m != nil {
		return m.Vrf
	}
	return 0
}

type PolicyACLFlow_Action struct {
	Name  PolicyACLFlow_Action_Name `protobuf:"varint,1,opt,name=name,enum=fibcapi.PolicyACLFlow_Action_Name" json:"name,omitempty"`
	Value uint32                    `protobuf:"varint,2,opt,name=value" json:"value,omitempty"`
}

func (m *PolicyACLFlow_Action) Reset()                    { *m = PolicyACLFlow_Action{} }
func (m *PolicyACLFlow_Action) String() string            { return proto.CompactTextString(m) }
func (*PolicyACLFlow_Action) ProtoMessage()               {}
func (*PolicyACLFlow_Action) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11, 1} }

func (m *PolicyACLFlow_Action) GetName() PolicyACLFlow_Action_Name {
	if m != nil {
		return m.Name
	}
	return PolicyACLFlow_Action_UNSPEC
}

func (m *PolicyACLFlow_Action) GetValue() uint32 {
	if m != nil {
		return m.Value
	}
	return 0
}

// 0x0vvvPPPP (vvv:VID, PPPP:port_id)
type L2InterfaceGroup struct {
	PortId          uint32 `protobuf:"varint,1,opt,name=port_id,json=portId" json:"port_id,omitempty"`
	VlanVid         uint32 `protobuf:"varint,2,opt,name=vlan_vid,json=vlanVid" json:"vlan_vid,omitempty"`
	VlanTranslation bool   `protobuf:"varint,3,opt,name=vlan_translation,json=vlanTranslation" json:"vlan_translation,omitempty"`
}

func (m *L2InterfaceGroup) Reset()                    { *m = L2InterfaceGroup{} }
func (m *L2InterfaceGroup) String() string            { return proto.CompactTextString(m) }
func (*L2InterfaceGroup) ProtoMessage()               {}
func (*L2InterfaceGroup) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *L2InterfaceGroup) GetPortId() uint32 {
	if m != nil {
		return m.PortId
	}
	return 0
}

func (m *L2InterfaceGroup) GetVlanVid() uint32 {
	if m != nil {
		return m.VlanVid
	}
	return 0
}

func (m *L2InterfaceGroup) GetVlanTranslation() bool {
	if m != nil {
		return m.VlanTranslation
	}
	return false
}

// 0x20VVNNNN (VV:VRF, NNNN:NeId)
type L3UnicastGroup struct {
	NeId    uint32 `protobuf:"varint,1,opt,name=ne_id,json=neId" json:"ne_id,omitempty"`
	PortId  uint32 `protobuf:"varint,2,opt,name=port_id,json=portId" json:"port_id,omitempty"`
	VlanVid uint32 `protobuf:"varint,3,opt,name=vlan_vid,json=vlanVid" json:"vlan_vid,omitempty"`
	EthDst  string `protobuf:"bytes,4,opt,name=eth_dst,json=ethDst" json:"eth_dst,omitempty"`
	EthSrc  string `protobuf:"bytes,5,opt,name=eth_src,json=ethSrc" json:"eth_src,omitempty"`
}

func (m *L3UnicastGroup) Reset()                    { *m = L3UnicastGroup{} }
func (m *L3UnicastGroup) String() string            { return proto.CompactTextString(m) }
func (*L3UnicastGroup) ProtoMessage()               {}
func (*L3UnicastGroup) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *L3UnicastGroup) GetNeId() uint32 {
	if m != nil {
		return m.NeId
	}
	return 0
}

func (m *L3UnicastGroup) GetPortId() uint32 {
	if m != nil {
		return m.PortId
	}
	return 0
}

func (m *L3UnicastGroup) GetVlanVid() uint32 {
	if m != nil {
		return m.VlanVid
	}
	return 0
}

func (m *L3UnicastGroup) GetEthDst() string {
	if m != nil {
		return m.EthDst
	}
	return ""
}

func (m *L3UnicastGroup) GetEthSrc() string {
	if m != nil {
		return m.EthSrc
	}
	return ""
}

// 0x90VVNNNN (VV:VRF, NNNN:NeId)
type MPLSInterfaceGroup struct {
	NeId    uint32 `protobuf:"varint,1,opt,name=ne_id,json=neId" json:"ne_id,omitempty"`
	PortId  uint32 `protobuf:"varint,2,opt,name=port_id,json=portId" json:"port_id,omitempty"`
	VlanVid uint32 `protobuf:"varint,3,opt,name=vlan_vid,json=vlanVid" json:"vlan_vid,omitempty"`
	EthDst  string `protobuf:"bytes,4,opt,name=eth_dst,json=ethDst" json:"eth_dst,omitempty"`
	EthSrc  string `protobuf:"bytes,5,opt,name=eth_src,json=ethSrc" json:"eth_src,omitempty"`
}

func (m *MPLSInterfaceGroup) Reset()                    { *m = MPLSInterfaceGroup{} }
func (m *MPLSInterfaceGroup) String() string            { return proto.CompactTextString(m) }
func (*MPLSInterfaceGroup) ProtoMessage()               {}
func (*MPLSInterfaceGroup) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *MPLSInterfaceGroup) GetNeId() uint32 {
	if m != nil {
		return m.NeId
	}
	return 0
}

func (m *MPLSInterfaceGroup) GetPortId() uint32 {
	if m != nil {
		return m.PortId
	}
	return 0
}

func (m *MPLSInterfaceGroup) GetVlanVid() uint32 {
	if m != nil {
		return m.VlanVid
	}
	return 0
}

func (m *MPLSInterfaceGroup) GetEthDst() string {
	if m != nil {
		return m.EthDst
	}
	return ""
}

func (m *MPLSInterfaceGroup) GetEthSrc() string {
	if m != nil {
		return m.EthSrc
	}
	return ""
}

// 0x9x0LLLLL (LLLL: label)
type MPLSLabelGroup struct {
	DstId    uint32         `protobuf:"varint,1,opt,name=dst_id,json=dstId" json:"dst_id,omitempty"`
	NewLabel uint32         `protobuf:"varint,2,opt,name=new_label,json=newLabel" json:"new_label,omitempty"`
	NeId     uint32         `protobuf:"varint,3,opt,name=ne_id,json=neId" json:"ne_id,omitempty"`
	NewDstId uint32         `protobuf:"varint,4,opt,name=new_dst_id,json=newDstId" json:"new_dst_id,omitempty"`
	GType    GroupMod_GType `protobuf:"varint,5,opt,name=g_type,json=gType,enum=fibcapi.GroupMod_GType" json:"g_type,omitempty"`
}

func (m *MPLSLabelGroup) Reset()                    { *m = MPLSLabelGroup{} }
func (m *MPLSLabelGroup) String() string            { return proto.CompactTextString(m) }
func (*MPLSLabelGroup) ProtoMessage()               {}
func (*MPLSLabelGroup) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *MPLSLabelGroup) GetDstId() uint32 {
	if m != nil {
		return m.DstId
	}
	return 0
}

func (m *MPLSLabelGroup) GetNewLabel() uint32 {
	if m != nil {
		return m.NewLabel
	}
	return 0
}

func (m *MPLSLabelGroup) GetNeId() uint32 {
	if m != nil {
		return m.NeId
	}
	return 0
}

func (m *MPLSLabelGroup) GetNewDstId() uint32 {
	if m != nil {
		return m.NewDstId
	}
	return 0
}

func (m *MPLSLabelGroup) GetGType() GroupMod_GType {
	if m != nil {
		return m.GType
	}
	return GroupMod_UNSPEC
}

func init() {
	proto.RegisterType((*Hello)(nil), "fibcapi.Hello")
	proto.RegisterType((*DpStatus)(nil), "fibcapi.DpStatus")
	proto.RegisterType((*PortStatus)(nil), "fibcapi.PortStatus")
	proto.RegisterType((*PortConfig)(nil), "fibcapi.PortConfig")
	proto.RegisterType((*FlowMod)(nil), "fibcapi.FlowMod")
	proto.RegisterType((*GroupMod)(nil), "fibcapi.GroupMod")
	proto.RegisterType((*VLANFlow)(nil), "fibcapi.VLANFlow")
	proto.RegisterType((*VLANFlow_Match)(nil), "fibcapi.VLANFlow.Match")
	proto.RegisterType((*VLANFlow_Action)(nil), "fibcapi.VLANFlow.Action")
	proto.RegisterType((*TerminationMacFlow)(nil), "fibcapi.TerminationMacFlow")
	proto.RegisterType((*TerminationMacFlow_Match)(nil), "fibcapi.TerminationMacFlow.Match")
	proto.RegisterType((*TerminationMacFlow_Action)(nil), "fibcapi.TerminationMacFlow.Action")
	proto.RegisterType((*MPLSFlow)(nil), "fibcapi.MPLSFlow")
	proto.RegisterType((*MPLSFlow_Match)(nil), "fibcapi.MPLSFlow.Match")
	proto.RegisterType((*MPLSFlow_Action)(nil), "fibcapi.MPLSFlow.Action")
	proto.RegisterType((*UnicastRoutingFlow)(nil), "fibcapi.UnicastRoutingFlow")
	proto.RegisterType((*UnicastRoutingFlow_Match)(nil), "fibcapi.UnicastRoutingFlow.Match")
	proto.RegisterType((*UnicastRoutingFlow_Action)(nil), "fibcapi.UnicastRoutingFlow.Action")
	proto.RegisterType((*BridgingFlow)(nil), "fibcapi.BridgingFlow")
	proto.RegisterType((*BridgingFlow_Match)(nil), "fibcapi.BridgingFlow.Match")
	proto.RegisterType((*BridgingFlow_Action)(nil), "fibcapi.BridgingFlow.Action")
	proto.RegisterType((*PolicyACLFlow)(nil), "fibcapi.PolicyACLFlow")
	proto.RegisterType((*PolicyACLFlow_Match)(nil), "fibcapi.PolicyACLFlow.Match")
	proto.RegisterType((*PolicyACLFlow_Action)(nil), "fibcapi.PolicyACLFlow.Action")
	proto.RegisterType((*L2InterfaceGroup)(nil), "fibcapi.L2InterfaceGroup")
	proto.RegisterType((*L3UnicastGroup)(nil), "fibcapi.L3UnicastGroup")
	proto.RegisterType((*MPLSInterfaceGroup)(nil), "fibcapi.MPLSInterfaceGroup")
	proto.RegisterType((*MPLSLabelGroup)(nil), "fibcapi.MPLSLabelGroup")
	proto.RegisterEnum("fibcapi.FFM", FFM_name, FFM_value)
	proto.RegisterEnum("fibcapi.DpStatus_Status", DpStatus_Status_name, DpStatus_Status_value)
	proto.RegisterEnum("fibcapi.PortStatus_Status", PortStatus_Status_name, PortStatus_Status_value)
	proto.RegisterEnum("fibcapi.PortConfig_Cmd", PortConfig_Cmd_name, PortConfig_Cmd_value)
	proto.RegisterEnum("fibcapi.FlowMod_Cmd", FlowMod_Cmd_name, FlowMod_Cmd_value)
	proto.RegisterEnum("fibcapi.FlowMod_Table", FlowMod_Table_name, FlowMod_Table_value)
	proto.RegisterEnum("fibcapi.GroupMod_Cmd", GroupMod_Cmd_name, GroupMod_Cmd_value)
	proto.RegisterEnum("fibcapi.GroupMod_GType", GroupMod_GType_name, GroupMod_GType_value)
	proto.RegisterEnum("fibcapi.VLANFlow_Action_Name", VLANFlow_Action_Name_name, VLANFlow_Action_Name_value)
	proto.RegisterEnum("fibcapi.TerminationMacFlow_Action_Name", TerminationMacFlow_Action_Name_name, TerminationMacFlow_Action_Name_value)
	proto.RegisterEnum("fibcapi.MPLSFlow_Action_Name", MPLSFlow_Action_Name_name, MPLSFlow_Action_Name_value)
	proto.RegisterEnum("fibcapi.UnicastRoutingFlow_Action_Name", UnicastRoutingFlow_Action_Name_name, UnicastRoutingFlow_Action_Name_value)
	proto.RegisterEnum("fibcapi.BridgingFlow_Action_Name", BridgingFlow_Action_Name_name, BridgingFlow_Action_Name_value)
	proto.RegisterEnum("fibcapi.PolicyACLFlow_Action_Name", PolicyACLFlow_Action_Name_name, PolicyACLFlow_Action_Name_value)
}

func init() { proto.RegisterFile("fibcapi.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 2007 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0x5f, 0x6f, 0xdb, 0xc8,
	0x11, 0x0f, 0x45, 0x91, 0x92, 0xc6, 0xb1, 0xb3, 0xde, 0x38, 0xb1, 0xe2, 0x24, 0x87, 0x9c, 0x0a,
	0x34, 0xc9, 0xa1, 0xf5, 0xc5, 0x74, 0xef, 0x0f, 0xda, 0xa0, 0xa8, 0x42, 0x51, 0x36, 0x01, 0x4a,
	0x64, 0x29, 0xca, 0x3e, 0x3f, 0x6d, 0x69, 0x89, 0x76, 0xd8, 0x48, 0x94, 0x2a, 0xd1, 0x0e, 0xd2,
	0xbe, 0xf4, 0xcf, 0x63, 0x81, 0xfe, 0x3f, 0xe0, 0x8a, 0xde, 0x63, 0xd1, 0x16, 0xe8, 0x4b, 0x1f,
	0xfa, 0x15, 0x0a, 0x14, 0xfd, 0x12, 0xed, 0x07, 0xe8, 0x87, 0x28, 0x66, 0x49, 0x8a, 0xa4, 0x24,
	0xff, 0x09, 0xae, 0xc0, 0x3d, 0x69, 0x67, 0x76, 0x66, 0x76, 0x38, 0xf3, 0x9b, 0x99, 0x5d, 0xc1,
	0xea, 0x89, 0x7f, 0xdc, 0x73, 0xc7, 0xfe, 0xf6, 0x78, 0x32, 0x0a, 0x47, 0xb4, 0x14, 0x93, 0xb5,
	0x07, 0x20, 0xed, 0x7b, 0x83, 0xc1, 0x88, 0xde, 0x06, 0x69, 0xe2, 0x31, 0xbf, 0x5f, 0x15, 0x1e,
	0x09, 0x4f, 0x2a, 0x76, 0x71, 0xe2, 0xe9, 0xfd, 0xda, 0x0f, 0xa1, 0xdc, 0x18, 0x77, 0x42, 0x37,
	0x3c, 0x9b, 0xd2, 0x67, 0x20, 0x4f, 0xf9, 0x8a, 0x4b, 0xac, 0x29, 0xd5, 0xed, 0xc4, 0x64, 0x22,
	0xb2, 0x1d, 0xfd, 0xd8, 0xb1, 0x5c, 0x6a, 0xb2, 0x90, 0x31, 0xf9, 0x18, 0xe4, 0xd8, 0x60, 0x09,
	0xc4, 0xb6, 0x69, 0x91, 0x1b, 0xb4, 0x02, 0x92, 0xd6, 0x76, 0x34, 0x9b, 0x08, 0xb8, 0x34, 0xb4,
	0xfa, 0x81, 0x46, 0x0a, 0xb5, 0xbf, 0x0a, 0x00, 0xd6, 0x68, 0x12, 0xc6, 0xd2, 0xca, 0xdc, 0xf1,
	0x5b, 0xb3, 0xe3, 0x53, 0xa1, 0xeb, 0x38, 0x40, 0x37, 0xa1, 0x34, 0x1e, 0x4d, 0x42, 0x64, 0x8b,
	0x8f, 0x84, 0x27, 0xab, 0xb6, 0x8c, 0xa4, 0xde, 0xa7, 0x77, 0x41, 0xf6, 0x4f, 0x02, 0x77, 0xe8,
	0x55, 0x8b, 0x5c, 0x3c, 0xa6, 0x6a, 0x5f, 0x59, 0xf4, 0x58, 0x86, 0x42, 0xd7, 0x22, 0x02, 0x2d,
	0x43, 0xb1, 0x61, 0x1e, 0xb6, 0x49, 0xa1, 0xf6, 0x8b, 0x42, 0xe4, 0xad, 0x3a, 0x0a, 0x4e, 0xfc,
	0x53, 0xfa, 0x14, 0xc4, 0xde, 0xb0, 0x1f, 0xbb, 0xba, 0x99, 0x73, 0x35, 0x92, 0xd8, 0x56, 0x87,
	0x7d, 0x1b, 0x65, 0x96, 0x3b, 0x99, 0xfa, 0x22, 0x66, 0x7d, 0xc9, 0x3a, 0x5f, 0xcc, 0x39, 0x4f,
	0xa1, 0x38, 0xf0, 0x83, 0x57, 0x55, 0x29, 0x32, 0x82, 0x6b, 0x34, 0x32, 0x1d, 0xb8, 0xe7, 0xde,
	0xb4, 0x2a, 0x3f, 0x12, 0xd1, 0x48, 0x44, 0x65, 0x42, 0x59, 0xba, 0x6e, 0x28, 0x6b, 0xef, 0x83,
	0xa8, 0x0e, 0xfb, 0x69, 0x04, 0x4a, 0x20, 0xd6, 0x1b, 0x0d, 0x22, 0x50, 0x00, 0xb9, 0x65, 0x36,
	0xf4, 0xe6, 0x11, 0x29, 0xe0, 0xba, 0xa1, 0x19, 0x9a, 0xa3, 0x11, 0xb1, 0xf6, 0x6f, 0x09, 0x4a,
	0xcd, 0xc1, 0xe8, 0x75, 0x6b, 0xd4, 0xa7, 0x5f, 0xcd, 0x46, 0x63, 0x63, 0x76, 0x5a, 0xbc, 0x9d,
	0x86, 0xe2, 0x6b, 0x20, 0x85, 0xee, 0xf1, 0xc0, 0xe3, 0xa1, 0x58, 0x53, 0xee, 0x2e, 0x48, 0x3a,
	0xb8, 0x6b, 0x47, 0x42, 0x69, 0xe0, 0xc4, 0x4c, 0xe0, 0x1e, 0x43, 0xf1, 0x7c, 0xe0, 0x06, 0x3c,
	0x3a, 0x2b, 0xca, 0xfa, 0xcc, 0xc2, 0x81, 0x51, 0x6f, 0xa3, 0x95, 0xfd, 0x1b, 0x36, 0x17, 0xa0,
	0x1f, 0x43, 0x39, 0xf4, 0x26, 0x43, 0x36, 0x74, 0x7b, 0x3c, 0x68, 0x2b, 0xca, 0xfd, 0x99, 0xb0,
	0xe3, 0x4d, 0x86, 0x7e, 0xe0, 0x86, 0xfe, 0x28, 0x68, 0xb9, 0xbd, 0x58, 0xad, 0x84, 0xe2, 0x2d,
	0xb7, 0x47, 0x9f, 0x82, 0x34, 0x1c, 0x0f, 0xa6, 0x3b, 0x55, 0x79, 0xee, 0x8c, 0x96, 0x65, 0x74,
	0x62, 0xe1, 0x48, 0x82, 0x7e, 0x04, 0xa5, 0xb3, 0xc0, 0xef, 0xb9, 0xd3, 0x90, 0x87, 0x3a, 0x7b,
	0x46, 0x37, 0xe2, 0xdb, 0xa3, 0xb3, 0xd0, 0x0f, 0x4e, 0x93, 0x33, 0x62, 0x69, 0xba, 0x0b, 0xe5,
	0xe3, 0x89, 0xdf, 0x3f, 0xf5, 0x83, 0xd3, 0x6a, 0x99, 0x6b, 0xde, 0x99, 0x69, 0xbe, 0x88, 0x37,
	0x62, 0x9d, 0x99, 0x20, 0x7d, 0x0f, 0x44, 0xb7, 0x37, 0xa8, 0x56, 0xb8, 0xfc, 0xdd, 0x4c, 0x52,
	0x07, 0x7e, 0xef, 0x4d, 0x5d, 0x35, 0x62, 0x05, 0x14, 0xaa, 0x75, 0xaf, 0x93, 0xcf, 0x75, 0x58,
	0x8d, 0xd6, 0xac, 0xe3, 0xd8, 0xba, 0xea, 0x10, 0x31, 0x93, 0xe2, 0x22, 0x6e, 0x47, 0xeb, 0x64,
	0x5b, 0xaa, 0xfd, 0x47, 0x00, 0x89, 0x27, 0x89, 0x12, 0xb8, 0xa9, 0xb7, 0xf7, 0x6c, 0xad, 0xd3,
	0x61, 0x96, 0x69, 0x3b, 0xe4, 0x06, 0x16, 0x0b, 0x66, 0x81, 0x00, 0xbd, 0x09, 0x65, 0x47, 0xb3,
	0x5b, 0xac, 0x55, 0x57, 0xc9, 0x06, 0x5d, 0x81, 0x92, 0xb1, 0xcb, 0x9c, 0x23, 0x4b, 0x23, 0x77,
	0xb0, 0x01, 0x60, 0x18, 0x9f, 0x91, 0xcd, 0x64, 0xb9, 0x43, 0xaa, 0xc9, 0x52, 0x21, 0xf7, 0xd0,
	0x2e, 0x2e, 0x59, 0xa2, 0x72, 0x9f, 0x6e, 0x00, 0x89, 0x38, 0xf5, 0x17, 0x9a, 0xc1, 0x1c, 0xbb,
	0xdb, 0x71, 0xc8, 0x03, 0xba, 0x0a, 0x15, 0xce, 0xe5, 0x42, 0x0f, 0xe9, 0x6d, 0xb8, 0xd5, 0x6d,
	0xeb, 0x6a, 0xbd, 0xe3, 0x30, 0xdb, 0xec, 0x3a, 0x7a, 0x7b, 0x8f, 0xbc, 0x43, 0xef, 0xc0, 0x7a,
	0xab, 0x6b, 0x38, 0x79, 0xf6, 0x13, 0x74, 0xef, 0x85, 0xad, 0x37, 0xf6, 0x90, 0x52, 0xe8, 0x1a,
	0x80, 0x65, 0x1a, 0xba, 0x7a, 0xc4, 0xea, 0xaa, 0x41, 0x9e, 0xbf, 0x28, 0x81, 0xe4, 0x05, 0xe1,
	0xe4, 0x4d, 0xed, 0xef, 0x32, 0x94, 0xf7, 0x26, 0xa3, 0xb3, 0x31, 0x42, 0xfc, 0x71, 0x16, 0xe2,
	0x69, 0xae, 0x92, 0xfd, 0x14, 0xe3, 0xdb, 0x20, 0x9f, 0xb2, 0xf0, 0xcd, 0x38, 0x01, 0xf9, 0xe6,
	0xa2, 0xec, 0x9e, 0xf3, 0x66, 0xec, 0xd9, 0xd2, 0x29, 0xfe, 0x2c, 0x47, 0xf9, 0x87, 0x50, 0x1e,
	0x28, 0xcc, 0x3f, 0x71, 0x7b, 0x5e, 0x8c, 0xf4, 0x7b, 0x33, 0x33, 0x86, 0xa2, 0x07, 0xa1, 0x37,
	0xc1, 0x3d, 0x6e, 0x11, 0x61, 0x35, 0x50, 0x74, 0xa4, 0xe9, 0xc7, 0x00, 0x83, 0x5d, 0x96, 0x40,
	0x32, 0x82, 0x7d, 0xea, 0x80, 0xb1, 0x1b, 0x83, 0x32, 0xd1, 0xab, 0x0c, 0x12, 0x0e, 0x7d, 0x0e,
	0x80, 0x90, 0x8e, 0xcf, 0x94, 0xe7, 0xc0, 0x8c, 0x91, 0x5e, 0x38, 0xb5, 0x82, 0x0a, 0xb3, 0x73,
	0xb9, 0xf6, 0xc0, 0x3d, 0xf6, 0x06, 0x71, 0x29, 0x6c, 0xe6, 0xb4, 0x0d, 0xdc, 0xc9, 0x69, 0x72,
	0xce, 0xdb, 0xf7, 0x9d, 0x4f, 0x45, 0x90, 0x78, 0x00, 0x91, 0xdb, 0x6d, 0x77, 0x2c, 0x4d, 0x25,
	0x37, 0x10, 0x35, 0x86, 0xc2, 0x74, 0x9c, 0x32, 0xcd, 0xba, 0xaa, 0x11, 0x01, 0xd3, 0x6a, 0x28,
	0xcc, 0xd6, 0x0e, 0x6d, 0xdd, 0xd1, 0x08, 0xe1, 0xf4, 0x2e, 0x8b, 0x31, 0x42, 0x1e, 0xc5, 0x1a,
	0x33, 0x78, 0x90, 0x67, 0x08, 0x0b, 0x43, 0x61, 0x4d, 0xc3, 0x34, 0x1b, 0xe4, 0x3b, 0x7c, 0x7f,
	0x37, 0x63, 0xd1, 0x8a, 0x39, 0xa9, 0xc6, 0xf7, 0x62, 0x64, 0x6b, 0x6a, 0xcb, 0x22, 0x63, 0x7a,
	0x07, 0x88, 0xa1, 0x30, 0xf3, 0x40, 0xb3, 0x8d, 0xfa, 0x11, 0x6b, 0x1a, 0xac, 0xab, 0x92, 0x1f,
	0x0b, 0x8b, 0xec, 0x96, 0x4a, 0x7e, 0x32, 0xcf, 0x6e, 0xa9, 0x28, 0xfd, 0xd3, 0x25, 0xec, 0x96,
	0x4a, 0x7e, 0x26, 0xd0, 0xdb, 0xb0, 0xc6, 0xc1, 0x9e, 0xba, 0xf3, 0x2b, 0x81, 0x12, 0x58, 0x89,
	0xea, 0x42, 0x61, 0x07, 0x56, 0x9b, 0xfc, 0x3a, 0xc3, 0xd9, 0xe5, 0x9c, 0xdf, 0x08, 0x74, 0x3d,
	0xae, 0x26, 0xa7, 0xdb, 0x6e, 0x6b, 0xc6, 0x0e, 0xf9, 0xed, 0x3c, 0x4b, 0x21, 0xbf, 0xc3, 0x58,
	0x45, 0xb5, 0xd4, 0x39, 0xac, 0x5b, 0xe4, 0x53, 0x81, 0xde, 0x84, 0x12, 0xa7, 0x9b, 0x4d, 0xf2,
	0xa7, 0x74, 0x97, 0x7f, 0xe7, 0x5f, 0x04, 0xba, 0x01, 0xb7, 0x0c, 0x85, 0x75, 0x9b, 0x19, 0x6f,
	0xfe, 0x26, 0xa4, 0x65, 0xf3, 0x2f, 0x11, 0xca, 0x49, 0x37, 0xa6, 0x5f, 0x07, 0x69, 0xe8, 0x86,
	0xbd, 0x97, 0xbc, 0x70, 0xb2, 0x98, 0x48, 0x24, 0xb6, 0x5b, 0xb8, 0x6d, 0x47, 0x52, 0x54, 0x81,
	0x92, 0xdb, 0xc3, 0xb6, 0x3c, 0xad, 0x16, 0x1e, 0x89, 0x4f, 0x56, 0x32, 0x97, 0x90, 0x99, 0x42,
	0x9d, 0x0b, 0xd8, 0x89, 0x20, 0x7d, 0x08, 0x70, 0x3a, 0x0a, 0x47, 0x2c, 0x9a, 0x2c, 0xd1, 0xc8,
	0xaf, 0x20, 0x87, 0xf7, 0xa9, 0xad, 0x16, 0x48, 0xfc, 0x08, 0x1c, 0xad, 0x7e, 0xc0, 0x70, 0x9c,
	0x72, 0x67, 0x56, 0x6d, 0xd9, 0x0f, 0x70, 0x1e, 0x52, 0x02, 0xe2, 0x79, 0x3c, 0x9e, 0x57, 0x6d,
	0x5c, 0xd2, 0x7b, 0x50, 0x3e, 0xf7, 0xfb, 0x6c, 0xe8, 0x4e, 0x5f, 0xc5, 0x06, 0x4b, 0xe7, 0x7e,
	0xbf, 0xe5, 0x4e, 0x5f, 0x6d, 0xfd, 0x57, 0x00, 0x39, 0xf2, 0x80, 0xee, 0x40, 0x91, 0x4f, 0xf0,
	0xa8, 0x27, 0x3c, 0xbc, 0xc8, 0xd3, 0xed, 0xb6, 0x3b, 0xf4, 0x6c, 0x2e, 0x4a, 0x37, 0x40, 0x3a,
	0x77, 0x07, 0x67, 0x5e, 0x7c, 0x58, 0x44, 0xd4, 0x3e, 0x13, 0xa0, 0x88, 0x42, 0xf3, 0x88, 0xee,
	0x68, 0x0e, 0x43, 0x63, 0xec, 0x40, 0xc7, 0x8a, 0x58, 0x81, 0x12, 0xe7, 0xd8, 0x4d, 0x52, 0x40,
	0xb0, 0x22, 0x61, 0xe2, 0x96, 0x88, 0x9d, 0x1a, 0xa9, 0xb4, 0x21, 0x16, 0xb1, 0x3f, 0x5a, 0xdd,
	0xce, 0x3e, 0x37, 0x40, 0x24, 0x94, 0xb7, 0x4c, 0x2b, 0xa2, 0x64, 0x6c, 0xa9, 0x33, 0x79, 0x43,
	0x89, 0x54, 0x4a, 0x89, 0x95, 0x08, 0x18, 0x4c, 0x6f, 0x90, 0x72, 0xed, 0x33, 0x11, 0xe8, 0xe2,
	0xb4, 0xa4, 0x1f, 0xe5, 0xd3, 0xfa, 0xee, 0x25, 0x93, 0x35, 0x9f, 0xe0, 0xe7, 0xf3, 0x09, 0xae,
	0x5d, 0xa6, 0xfa, 0x96, 0xa9, 0x1e, 0x5d, 0x99, 0xea, 0x7b, 0x50, 0xf6, 0xc2, 0x97, 0x69, 0x7b,
	0x5e, 0xb5, 0x4b, 0x5e, 0xf8, 0x92, 0x77, 0x93, 0x4d, 0xc0, 0x25, 0xeb, 0x4f, 0xc3, 0xe4, 0x4a,
	0xe6, 0x85, 0x2f, 0x1b, 0x53, 0xae, 0x83, 0x17, 0x0a, 0x76, 0x3e, 0xbb, 0x93, 0x95, 0x90, 0x3e,
	0xf0, 0xfb, 0x5b, 0x3f, 0x9a, 0x61, 0xe1, 0x5b, 0x39, 0x2c, 0x3c, 0xbe, 0xfa, 0xa3, 0xae, 0x46,
	0xc5, 0x3b, 0x4b, 0x40, 0x01, 0x20, 0x9b, 0x5d, 0xc7, 0xea, 0x3a, 0x44, 0xa8, 0x7d, 0x2e, 0x41,
	0x39, 0xb9, 0x91, 0x5c, 0x5c, 0x67, 0x89, 0xc4, 0xb5, 0xeb, 0x6c, 0xa6, 0x30, 0x1f, 0xfc, 0x74,
	0xb0, 0x89, 0xd7, 0x1a, 0x6c, 0xeb, 0x50, 0x3c, 0x4d, 0xef, 0xb1, 0xe2, 0xa9, 0xde, 0x9f, 0xcb,
	0x9f, 0x34, 0x9f, 0xbf, 0xf7, 0x93, 0xfc, 0x11, 0x10, 0x8f, 0x47, 0xd1, 0x43, 0xa0, 0x6c, 0xe3,
	0x12, 0x43, 0x14, 0xcd, 0x96, 0x38, 0x44, 0x9c, 0xd8, 0xfa, 0xbd, 0x78, 0x65, 0x31, 0xce, 0x7d,
	0xce, 0xd5, 0x61, 0xff, 0x47, 0x61, 0x49, 0xdc, 0xb1, 0x98, 0x4c, 0x2b, 0xba, 0x81, 0x44, 0x95,
	0xd8, 0xd0, 0x54, 0xe6, 0x38, 0x06, 0x29, 0xd0, 0x5b, 0xb0, 0xa2, 0x9a, 0xd6, 0x11, 0x52, 0x4c,
	0x6f, 0x13, 0x11, 0x27, 0x4d, 0xc4, 0x50, 0x91, 0x2e, 0x66, 0xeb, 0x56, 0x9a, 0xaf, 0x3c, 0x7e,
	0x75, 0x92, 0x17, 0xeb, 0x77, 0x59, 0x31, 0x26, 0xac, 0xef, 0x9a, 0x38, 0x08, 0x1a, 0xda, 0x27,
	0xa4, 0x82, 0x37, 0x1c, 0x2e, 0x65, 0xd7, 0x9b, 0x4d, 0x5d, 0x65, 0xaa, 0x51, 0xef, 0x74, 0x08,
	0x50, 0x0a, 0x6b, 0xc8, 0xe6, 0x03, 0x2c, 0x3a, 0x63, 0x65, 0xe6, 0x56, 0x53, 0xd7, 0x8c, 0x06,
	0xb9, 0x89, 0xd6, 0xf0, 0x9b, 0xd4, 0x43, 0x66, 0xda, 0xac, 0xae, 0xee, 0x93, 0xd5, 0x5c, 0x93,
	0x58, 0x4b, 0x04, 0x0c, 0x85, 0xed, 0x6b, 0xf5, 0x86, 0x66, 0x93, 0x5b, 0xf8, 0xad, 0xdc, 0x6e,
	0x4b, 0xb3, 0xd0, 0x25, 0x42, 0xab, 0xb0, 0x81, 0x0c, 0xcb, 0x36, 0x1d, 0x4d, 0x75, 0x74, 0xb3,
	0x1d, 0x7b, 0xb6, 0x5e, 0xfb, 0x5c, 0x04, 0xba, 0x78, 0x07, 0xbe, 0xb8, 0x73, 0x2c, 0xca, 0xe6,
	0x21, 0xfb, 0x4d, 0x90, 0x23, 0x24, 0xf2, 0x74, 0x65, 0x1b, 0xc7, 0x12, 0xcd, 0x18, 0xbb, 0xb1,
	0xc6, 0xff, 0x01, 0xba, 0x5b, 0xcf, 0x12, 0x6c, 0xde, 0x01, 0xd9, 0x1f, 0xf3, 0x36, 0x11, 0x3d,
	0xa4, 0x25, 0x7f, 0x8c, 0x5d, 0x02, 0x87, 0xc8, 0xe4, 0x64, 0x36, 0x44, 0x26, 0x27, 0x5b, 0x7f,
	0x10, 0xae, 0xec, 0x0e, 0x17, 0x7a, 0x7e, 0x35, 0x4c, 0xbf, 0x7d, 0x79, 0x77, 0xc0, 0xe4, 0xa9,
	0x86, 0x56, 0xc7, 0xcc, 0x62, 0x5a, 0x3a, 0xa4, 0x90, 0x45, 0xad, 0x58, 0xfb, 0x67, 0x01, 0x6e,
	0x66, 0x1f, 0x1a, 0x74, 0x27, 0x9f, 0x98, 0xfb, 0x4b, 0x9f, 0x23, 0xf9, 0x94, 0x7c, 0x63, 0x2e,
	0x25, 0x0f, 0x96, 0xeb, 0xe4, 0x93, 0xb1, 0xf5, 0x49, 0xa6, 0x4b, 0x27, 0x1d, 0x57, 0xb8, 0xb0,
	0xe3, 0x16, 0x72, 0x1d, 0x97, 0xde, 0x87, 0x4a, 0x78, 0x16, 0x04, 0xde, 0x20, 0x7d, 0xde, 0x97,
	0x23, 0x86, 0xde, 0xdf, 0x3a, 0x9b, 0x05, 0xfc, 0x83, 0x5c, 0xc0, 0xdf, 0xbd, 0xcc, 0xaf, 0x2f,
	0xde, 0x88, 0xff, 0x58, 0x80, 0xd5, 0xdc, 0x1b, 0x8c, 0x2a, 0xf9, 0x58, 0x3e, 0x58, 0xfe, 0x54,
	0xcb, 0x07, 0xf3, 0x83, 0xb9, 0x60, 0x3e, 0xbc, 0x40, 0x69, 0x2e, 0x9a, 0x6f, 0x8f, 0xcb, 0xf3,
	0x59, 0x94, 0x3e, 0xcc, 0x45, 0xa9, 0x76, 0xe9, 0x81, 0x5f, 0x3c, 0x4c, 0x3f, 0xc0, 0xab, 0x6d,
	0xfe, 0x11, 0x91, 0xfd, 0xbb, 0x43, 0xc8, 0xfd, 0xdd, 0x71, 0x09, 0x04, 0x9e, 0x02, 0xe1, 0x5b,
	0xe1, 0xc4, 0x0d, 0xa6, 0x03, 0x3e, 0x5a, 0x39, 0x12, 0xca, 0xf6, 0x2d, 0xe4, 0x3b, 0x29, 0xbb,
	0xf6, 0x73, 0x01, 0xd6, 0xf2, 0x8f, 0x1e, 0x7c, 0x6e, 0x05, 0x5e, 0x7a, 0x5e, 0x31, 0x98, 0xfb,
	0xcb, 0xa8, 0x70, 0xa1, 0x1b, 0x62, 0xde, 0x8d, 0x0c, 0x7a, 0x8b, 0x39, 0xf4, 0xc6, 0x1b, 0xd3,
	0x49, 0x2f, 0xfe, 0xb3, 0x06, 0x37, 0x3a, 0x93, 0x5e, 0xed, 0x97, 0x02, 0xd0, 0xc5, 0x87, 0xd4,
	0x97, 0xe9, 0xd1, 0x9f, 0x85, 0xe8, 0x5d, 0x91, 0x3e, 0xce, 0x10, 0x46, 0xfd, 0x69, 0x26, 0x21,
	0x52, 0x7f, 0x8a, 0xc7, 0xde, 0x87, 0x4a, 0xe0, 0xbd, 0x66, 0xd9, 0x19, 0x5c, 0x0e, 0xbc, 0xd7,
	0x5c, 0x31, 0xfd, 0x02, 0x31, 0xf3, 0x05, 0x0f, 0x00, 0x50, 0x23, 0x36, 0x56, 0x9c, 0xa9, 0x34,
	0xb8, 0xbd, 0xb4, 0x23, 0x4b, 0xd7, 0xe9, 0xc8, 0xef, 0x7d, 0x1f, 0xc4, 0x66, 0xb3, 0x95, 0xc3,
	0x56, 0x05, 0xa4, 0x7d, 0xcd, 0x30, 0x4c, 0x22, 0xe0, 0x58, 0xc2, 0x21, 0xc7, 0x3a, 0x4e, 0xdd,
	0xe9, 0x76, 0xa2, 0x99, 0xcc, 0x19, 0xaa, 0xd9, 0x6e, 0xea, 0x7b, 0x44, 0xc4, 0xc9, 0xd6, 0x34,
	0xcc, 0x43, 0xd6, 0x32, 0x1b, 0xd1, 0xdd, 0x78, 0xcf, 0x36, 0xbb, 0x16, 0x27, 0x25, 0x24, 0x1b,
	0x56, 0xa2, 0x2c, 0x1f, 0xcb, 0xfc, 0x2f, 0xd4, 0xdd, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x43,
	0x3c, 0x8f, 0x75, 0x53, 0x15, 0x00, 0x00,
}
